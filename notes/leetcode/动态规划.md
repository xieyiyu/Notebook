# 动态规划
Dynamic Programming： 分阶段求解问题  
三要素：最优子结构、边界、状态转移公式  
一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。

### 台阶问题
[Leetcode : 70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/description/)

>You are climbing a stair case. It takes n steps to reach to the top.  
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

问题描述：分解为子问题，F(n) = F(n-1) + F(n-2),是一个斐波那契数列，可以直接用递归求解，但递归的时间复杂度是指数级别的 o(n<sup>2</sup>) ，会出现参数被重复计算的问题。  
利用动态规划求解：F(n-1) 和 F(n-2) 是 F(n) 的最优子结构，F(1) 和 F(2) 是问题边界（可以直接得出结果，不需要继续简化），F(n) = F(n-1) + F(n-2) 即状态转移公式。  
自底向上对该问题进行求解，由于 F(n) 只依赖于 F(n-1) 和 F(n-2)，因此可以使用中间变量将其进行保存，从 1-n 依次迭代。此时时间复杂度为 o(n),空间复杂度为 o(1)

```python
def climb_stairs(n):
    a = b = 1
    for _ in range(n):  #1
        a, b = b, a+b   #2
    return a
```

备注：  
1. python 中无需关心其实际含义的变量可用 _ 代替，仅需要循环，不需要计数  
2. a 表示到当前台阶的方法数，b 表示到下一台阶的方法数

### 爬楼梯的最低成本
[Leetcode : 746. Min Cost Climbing Stairs (Easy)](https://leetcode.com/problems/min-cost-climbing-stairs/description/)

>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  
>  
>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]  
Output: 6  
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].  
>
>Note:cost will have a length in the range [2, 1000].Every cost[i] will be an integer in the range [0, 999].

问题描述：爬楼梯，每次可以走一层或者两层，每层都有一个花费 cost[i]， 求到顶点时的最小花费。  
  
方法一：  
可以用一个列表 dp[i] 来表示到达第 i 层的花费(到达第 i 层时不需要加上 cost[i])，则我们要求的到顶点的花费即为 dp[len(cost)]， dp[] 的长度比 cost[] 的长度更大 1。  
因此到达第 i 层时，可能是从 i-1 层跳上来，也可能是从 i-2 层跳上来，需要求这两种情况下的最小值。  
dp[i] = min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])  
该方法的时间复杂度为 o(n)，空间复杂度为 o(n)

```python
def min_cost_climb_stairs(cost):
    dp = [0, 0]
    for i in range(2, len(cost)+1):
        dp.append(min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]))
    return dp[len(cost)]
```

方法二：  
由于 dp[i] 只与 dp[i-2] 和 dp[i-1] 以及 cost 有关，因此用三个变量即可。用 pre1 代表 dp[i-1]，用 pre2 代表 dp[i-2]， 用 cur 代表 dp[i]。  
该方法的时间复杂度为 o(n)，空间复杂度为 o(1)

```python
def min_cost_climb_stairs(cost):
    pre1, pre2 = 0, 0
    for i in range(2, len(cost) + 1):
        cur = min(pre2 + cost[i-2], pre1 + cost[i-1])
        pre2 = pre1
        pre1 = cur
    return cur
```

### 强盗抢劫房子
[Leetcode : 198. House Robber (Easy)](https://leetcode.com/problems/house-robber/description/)

>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.  
>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：抢劫一排住户，不能抢相邻的，求最大的抢劫金额。与上一题相似。  

抢劫到第 i 个住户时最大的抢劫量为 dp[i]，由于不能抢 i-1 的住户，因此此时只能抢 i-2 或 i-3 的住户，因此 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值；
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2],dp[i-3])+nums[i]"/></div> <br>

方法一：采用**备忘录算法**，该解法的时间复杂度为 o(n),空间复杂度为 o(n)，使用列表 dp[] 来记录下抢劫到第 i 个房子时最大的抢劫量。
```python
def rob(nums):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    dp = []
    dp.append(nums[0])
    dp.append(max(nums[0], nums[1]))
    dp.append(max(nums[0]+nums[2], nums[1]))
    for i in range(3, size):
        dp.append(max(dp[i-2], dp[i-3]) + nums[i])
    return max(dp[size-1], dp[size-2])
```

方法二：改进算法，空间复杂度 o(1) 实现。由于 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值，因此需要记录下这两个的值。

```python
size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])

    pre3 = nums[0] # dp[i-3]
    pre2 = nums[1] # dp[i-2]
    pre1 = nums[0] + nums[2]
    for i in range(3, size):
        cur = max(pre2, pre3) + nums[i]
        pre3, pre2, pre1 = pre2, pre1, cur
    return max(pre1,pre2)
```

### 强盗抢劫房子II
[Leetcode : 213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/description/)

>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.  
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：房子的分布变为环形，即第一个和最后一个相邻，可以分别求去掉第一个的最大值，和去掉最后一个的最大值，然后比较两者的大小

```python
def rob2(nums):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    if size == 3:
        return max(nums[0], nums[1], nums[2])
    return max(rob_circle(nums[0:size-1]), rob_circle(nums[1:size]))

def rob_circle(nums):
    pre3 = nums[0]  # dp[i-3]
    pre2 = nums[1]  # dp[i-2]
    pre1 = nums[0] + nums[2]  # dp[i-1]
    for i in range(3, len(nums)):
        cur = max(pre2, pre3) + nums[i]
        pre3, pre2, pre1 = pre2, pre1, cur
    return max(pre1, pre2)
```

### 股票最大收益
[Leetcode : 121. Best Time to Buy and Sell Stock (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

>Say you have an array for which the ith element is the price of a given stock on day i.  
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.  
>
>Input: [7, 1, 5, 3, 6, 4]  
Output: 5  
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)

问题描述：只能买入和卖出一次，求股票最大的收益。若是持续下跌，则收益为 0。  
记录下最小值和最大的收益，遍历一遍，时间 o(n) 空间 o(1)

```python
def max_profit(prices):
    if len(prices) == 0:
        return 0
    profit = 0
    pmin = prices[0]
    for i in range(len(prices)):
        if prices[i] < pmin:
            pmin = prices[i]
        if prices[i] - pmin > profit:
            profit = prices[i] - pmin
    return profit
```

