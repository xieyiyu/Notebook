# 动态规划
Dynamic Programming： 分阶段求解问题
三要素：最优子结构、边界、状态转移公式  
一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。

## 斐波那契数列 Fibonacci 
### 台阶问题
>You are climbing a stair case. It takes n steps to reach to the top.  
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

问题描述：分解为子问题，F(n) = F(n-1) + F(n-2),是一个斐波那契数列，可以直接用递归求解，但递归的时间复杂度是指数级别的o(n<sup>2</sup>)，会出现参数被重复计算的问题。  
利用动态规划求解：F(n-1)和F(n-2)是F(n)的最优子结构，F(1)和F(2)是问题边界（可以直接得出结果，不需要继续简化），F(n) = F(n-1) + F(n-2)即状态转移公式。  
自底向上对该问题进行求解，由于F(n)只依赖于F(n-1)和F(n-2)，因此可以使用中间变量将其进行保存，从1-n依次迭代。此时时间复杂度为o(n),空间复杂度为o(1)

```python
def climb_stairs(n):
    a = b = 1
    for _ in range(n):  #1
        a, b = b, a+b   #2
    return a
```

备注：  
1. python中无需关心其实际含义的变量可用_代替，仅需要循环，不需要计数  
2. a表示到当前台阶的方法数，b表示到下一台阶的方法数

### 强盗抢劫房子
[Leetcode : 198. House Robber (Easy)](https://leetcode.com/problems/house-robber/description/)

>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.  
>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：抢劫一排住户，不能抢相邻的，求最大的抢劫金额。  

抢劫到第i个住户时最大的抢劫量为dp[i]，由于不能抢i-1的住户，因此此时只能抢i-2或i-3的住户，因此dp[i]依赖于dp[i-2]和dp[i-3]的值；
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2],dp[i-3])+nums[i]"/></div> <br>

方法一：采用**备忘录算法**，该解法的时间复杂度为o(n),空间复杂度为o(n)，使用列表dp[]来记录下抢劫到第i个房子时最大的抢劫量。
```python
def rob(nums):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    dp = []
    dp.append(nums[0])
    dp.append(max(nums[0], nums[1]))
    dp.append(max(nums[0]+nums[2], nums[1]))
    for i in range(3, size):
        dp.append(max(dp[i-2], dp[i-3]) + nums[i])
    return max(dp[size-1], dp[size-2])
```

方法二：改进算法，空间复杂度o(1)实现。由于dp[i]依赖于dp[i-2]和dp[i-3]的值，因此需要记录下这两个的值。

```python
size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])

    pre3 = nums[0] # dp[i-3]
    pre2 = nums[1] # dp[i-2]
    pre1 = nums[0] + nums[2]
    for i in range(3, size):
        cur = max(pre2, pre3) + nums[i]
        pre3, pre2, pre1 = pre2, pre1, cur
    return max(pre1,pre2)
```

### 强盗抢劫房子II
[Leetcode : 213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/description/)

>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.  
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：

### 整数分解
[Leetcode : 343. Integer Break (Medim)](https://leetcode.com/problems/integer-break/description/)

>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.  
For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).  
Note: You may assume that n is not less than 2 and not larger than 58.

问题描述：

```python
```