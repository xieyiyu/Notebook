# 动态规划
Dynamic Programming： 分阶段求解问题  
三要素：最优子结构、边界、状态转移公式  
一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。

<!-- GFM-TOC -->
* [斐波那契数列](#斐波那契数列)
    * [台阶问题](#台阶问题)
    * [爬楼梯的最低成本](#爬楼梯的最低成本)
    * [强盗抢劫房子](#强盗抢劫房子)
    * [强盗抢劫房子II](#强盗抢劫房子II)
* [0-1背包](#0-1背包)
* [其他](#其他)
    * [股票最大收益](#股票最大收益)
    * [子数组最大和](#子数组最大和)
<!-- GFM-TOC -->

## 斐波那契数列
### 台阶问题
[Leetcode : 70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/description/)

>You are climbing a stair case. It takes n steps to reach to the top.  
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

问题描述：分解为子问题，F(n) = F(n-1) + F(n-2),是一个斐波那契数列，可以直接用递归求解，但递归的时间复杂度是指数级别的 o(n<sup>2</sup>) ，会出现参数被重复计算的问题。  
利用动态规划求解：F(n-1) 和 F(n-2) 是 F(n) 的最优子结构，F(1) 和 F(2) 是问题边界（可以直接得出结果，不需要继续简化），F(n) = F(n-1) + F(n-2) 即状态转移公式。  
自底向上对该问题进行求解，由于 F(n) 只依赖于 F(n-1) 和 F(n-2)，因此可以使用中间变量将其进行保存，从 1-n 依次迭代。此时时间复杂度为 o(n),空间复杂度为 o(1)

```python
def climb_stairs(n):
    a = b = 1
    if n == 1:
        return 1
    for i in range(1,n):
        cur = a + b
        a = b
        b = cur
    return cur
```

备注：  
1. python 中无需关心其实际含义的变量可用 _ 代替，仅需要循环，不需要计数  
2. a 表示到 i-2 台阶的方法数，b 表示到 i-1 台阶的方法数，cur 表示到当前台阶的方法数

### 爬楼梯的最低成本
[Leetcode : 746. Min Cost Climbing Stairs (Easy)](https://leetcode.com/problems/min-cost-climbing-stairs/description/)

>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).  
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.  
>  
>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]  
Output: 6  
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].  
>
>Note:cost will have a length in the range [2, 1000].Every cost[i] will be an integer in the range [0, 999].

问题描述：爬楼梯，每次可以走一层或者两层，每层都有一个花费 cost[i]， 求到顶点时的最小花费。  
  
方法一：  
可以用一个列表 dp[i] 来表示到达第 i 层的花费(到达第 i 层时不需要加上 cost[i])，则我们要求的到顶点的花费即为 dp[len(cost)]， dp[] 的长度比 cost[] 的长度更大 1。  
因此到达第 i 层时，可能是从 i-1 层跳上来，也可能是从 i-2 层跳上来，需要求这两种情况下的最小值。  
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=min(dp[i-2]&plus;cost[i-2],dp[i-1]&plus;cost[i-1])"></div>
该方法的时间复杂度为 o(n)，空间复杂度为 o(n)

```python
def min_cost_climb_stairs(cost):
    dp = [0, 0]
    for i in range(2, len(cost)+1):
        dp.append(min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]))
    return dp[len(cost)]
```

方法二：  
由于 dp[i] 只与 dp[i-2] 和 dp[i-1] 以及 cost 有关，因此用三个变量即可。用 pre1 代表 dp[i-1]，用 pre2 代表 dp[i-2]， 用 cur 代表 dp[i]。  
该方法的时间复杂度为 o(n)，空间复杂度为 o(1)

```python
def min_cost_climb_stairs(cost):
    pre1, pre2 = 0, 0
    for i in range(2, len(cost) + 1):
        cur = min(pre2 + cost[i-2], pre1 + cost[i-1])
        pre2 = pre1
        pre1 = cur
    return cur
```

### 强盗抢劫房子
[Leetcode : 198. House Robber (Easy)](https://leetcode.com/problems/house-robber/description/)

>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.  
>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：抢劫一排住户，不能抢相邻的，求最大的抢劫金额。与上一题相似。  

抢劫到第 i 个住户时最大的抢劫量为 dp[i]，由于不能抢 i-1 的住户，因此此时只能抢 i-2 或 i-3 的住户，因此 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值；
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2],dp[i-3])+nums[i]"/></div> <br>

方法一：采用**备忘录算法**，该解法的时间复杂度为 o(n),空间复杂度为 o(n)，使用列表 dp[] 来记录下抢劫到第 i 个房子时最大的抢劫量。
```python
def rob(nums):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    dp = []
    dp.append(nums[0])
    dp.append(max(nums[0], nums[1]))
    dp.append(max(nums[0]+nums[2], nums[1]))
    for i in range(3, size):
        dp.append(max(dp[i-2], dp[i-3]) + nums[i])
    return max(dp[size-1], dp[size-2])
```

方法二：改进算法，空间复杂度 o(1) 实现。由于 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值，因此需要记录下这两个的值。

```python
size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])

    pre3 = nums[0] # dp[i-3]
    pre2 = nums[1] # dp[i-2]
    pre1 = nums[0] + nums[2]
    for i in range(3, size):
        cur = max(pre2, pre3) + nums[i]
        pre3, pre2, pre1 = pre2, pre1, cur
    return max(pre1,pre2)
```

### 强盗抢劫房子II
[Leetcode : 213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/description/)

>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.  
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

问题描述：房子的分布变为环形，即第一个和最后一个相邻，可以分别求去掉第一个的最大值，和去掉最后一个的最大值，然后比较两者的大小

```python
def rob2(nums):
    size = len(nums)
    if size == 0:
        return 0
    if size == 1:
        return nums[0]
    if size == 2:
        return max(nums[0], nums[1])
    if size == 3:
        return max(nums[0], nums[1], nums[2])
    return max(rob_circle(nums[0:size-1]), rob_circle(nums[1:size]))

def rob_circle(nums):
    pre3 = nums[0]  # dp[i-3]
    pre2 = nums[1]  # dp[i-2]
    pre1 = nums[0] + nums[2]  # dp[i-1]
    for i in range(3, len(nums)):
        cur = max(pre2, pre3) + nums[i]
        pre3, pre2, pre1 = pre2, pre1, cur
    return max(pre1, pre2)
```

## 其他

### 股票最大收益
[Leetcode : 121. Best Time to Buy and Sell Stock (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

>Say you have an array for which the ith element is the price of a given stock on day i.  
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.  
>
>Input: [7, 1, 5, 3, 6, 4]  
Output: 5  
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)

问题描述：只能买入和卖出一次，求股票最大的收益。若是持续下跌，则收益为 0。  
记录下最小值和最大的收益，遍历一遍，时间 o(n) 空间 o(1)

```python
def max_profit(prices):
    if len(prices) == 0:
        return 0
    profit = 0
    pmin = prices[0]
    for i in range(len(prices)):
        if prices[i] < pmin:
            pmin = prices[i]
        if prices[i] - pmin > profit:
            profit = prices[i] - pmin
    return profit
```

### 子数组最大和
[Leetcode : 53. Maximum Subarray (Easy)](https://leetcode.com/problems/maximum-subarray/description/)

>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.  
For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

问题描述：找到一个数组中的连续子数组的最大的和。  
  
到第 i 个数时的子数组最大和只可能是 sum[i-1] + nums[i] 或者是 nums[i-1]自身， 即  
sum[i] = max(sum[i-1] + nums[i], nums[i])  
当前 i-1 项的和 sum[i-1] <= 0 时，则 sum[i]
 = nums[i]， 抛弃之前的子数组，从 i 开始寻找新的最大和的子数组。这样就可以得到每一部分的最大的 sum，最后再从每一部分的最大 sum 中找到整个数组的 max_sum 。  
 
```python
def max_subArray(nums):
    if len(nums) == 0:
        return 0
    sum = 0
    max_sum = nums[0]
    for i in range(len(nums)):
        sum = max(sum + nums[i], nums[i])
        max_sum = max(max_sum, sum)
    return max_sum 
```

### 完全平方数
[Leetcode : 279. Perfect Squares(Medium)](https://leetcode.com/problems/perfect-squares/description/)

>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.  
For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.

问题描述：按完全平方数来分割整数，将一个数 n 分割成 1,4,9,16…… 的和。

```python```

## 0-1背包
0-1 背包问题是在 M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。  
  
定义二维数组 dp 来存储最大价值，dp[i][j] 表示体积为 j 的背包，前 i 件物品能够达到的最大价值。对于第 i 件物品，有两种情况：  
1. 不放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值，即 dp[i][j] = dp[i-1][j]；  
2. 放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值加上第 i 件物品的价值，即 dp[i][j] = dp[i-1][j-w[i]] + v[i]。  
  
选出上述两种情况下的最大价值，则为空间为 j 的背包能够放下的物品的最大价值。因此，可以得到状态转移方程为：

<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]&plus;v[i])"></div>
  
**方法一**：以填充格子的形式求解，返回最后一个格子即得到最大价值。  
该方法的时间复杂度为 o(N*M), 空间复杂度为 o(N*M)
```python
def bag_01(M, N, weights, values):
    dp = [[0 for j in range(N+1)] for i in range(M)] # 初始化二维数组，物品数 M 为行，背包容量 N 为列
    for j in range(N+1):
        dp[0][j] = values[0] if j >= weights[0] else 0 # 填充边界
    for i in range(1, M):
        for j in range(1, N+1):
            dp[i][j] = dp[i-1][j]
            if j >= weights[i]:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])
    return dp[M-1][N]
```
填完表格后，仅能得到最优解，但不知道最优解由哪些元素组成，通过最优解回溯，可以找到选择的物品。  
1. 当 dp[i][j] = dp[i-1][j] 时，说明第 i 件物品没有被选择， 则回到 dp[i-1][j]  
2. 当 dp[i][j] = dp[i-1][j-weights[i]] + values[i], 说明选择了第 i 件物品，然后再回到装该物品之前的状态，即 dp[i-1][j-weights[i]] 时  
3. 遍历到 i=0 时，找到组成最优解的商品  
  
```python
def bag_res(dp, N, M, weights, values):
    j = N
    res = []
    for i in range(M-1, -1, -1):
        print(i, dp[i-1][j-weights[i]])
        if dp[i][j] == dp[i-1][j-weights[i]] + values[i]:
            res.append(i+1)
            j = j - weights[i]
    return res
```
  
**方法二**：优化空间。由状态转移公式可知，前 i 件物品的状态只与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，用 dp[j] 来表示 dp[i][j] 和 dp[i-1][j]。此时的状态转移方程为：
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-weights[i]]&plus;values[i])"></div>
  
此时时间复杂度为 o(M*N), 空间复杂度为 o(N)  

需要注意的是：dp[] 填充时，必须要从右到左进行填充，也就是 j 应该倒序循环求解。否则，前一项的值即 dp[j-weights[i]] 改变了，dp[j] 无法求得正确的结果。  
  
但使用该方法，由于之前的数据被覆盖掉，只能够得到最后的最大价值，无法知道最优解由哪些元素组成，两种方法各有利弊。
```python
def bag01(M, N, weights, values):
    dp = [0]*(N+1)
    for i in range(0, M):
        for j in range(N, -1, -1):
            if dp[j] <= dp[j-weights[i]] + values[i] and j-weights[i] >= 0:
                dp[j] = dp[j-weights[i]] + values[i]
    return dp[N]
```

### 划分数组为和相等的两部分
[Leetcode : 416. Partition Equal Subset Sum (Medium)](https://leetcode.com/problems/partition-equal-subset-sum/description/)

>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.  
Note:Each of the array element will not exceed 100.The array size will not exceed 200.  
  
Input: [1, 5, 11, 5]  
Output: true  
Explanation: The array can be partitioned as [1, 5, 5] and [11].

问题描述：将一个数组划分为和相等的两部分。可以看成是一个背包大小为 sum/2 的 0-1背包问题，且这个背包必须要被填满。可以用一个一维数组进行求解，将每个数字所占空间和价值都用 nums[i] 来表示。由题意得到的状态转移公式为：
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-nums[i]]&plus;nums[i])"></div>
  
```python
def can_partition(nums):
    if len(nums) <= 1:
        return False
    V = sum(nums) // 2
    if 2 * V != sum(nums):
        return False
    dp = [0] * (V + 1)
    for i in range(len(nums)):
        for j in range(V, -1, -1):
            if dp[j] <= dp[j - nums[i]] + nums[i] and j - nums[i] >= 0:
                dp[j] = dp[j - nums[i]] + nums[i]
                if dp[j] == V:
                    return True
    return False
```