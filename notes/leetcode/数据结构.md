# 数据结构

<!-- GFM-TOC -->
* [栈与队列](#栈与队列)
    * [用栈实现队列](#用栈实现队列)
    * [用队列实现栈](#用队列实现栈)
    * [最小值栈](#最小值栈)
    * [用栈实现括号匹配](#用栈实现括号匹配)
* [哈希表](#哈希表)
    * [两数之和](#两数之和)
    * [同构字符串](#同构字符串)
    * [最长和谐序列](#最长和谐序列)
* [二叉树](#二叉树)
    * [递归](#递归)
        * [二叉树的高度](#二叉树的高度)
        * [二叉树的最小高度](#二叉树的最小高度)
        * [反转二叉树](#反转二叉树)
        * [归并二叉树](#归并二叉树)
        * [路径和](#路径和)
        * [对称树](#对称树)
        * [平衡二叉树](#平衡二叉树)
    * [遍历](#遍历)
        * [前序遍历](#前序遍历)
        * [中序遍历](#中序遍历)
        * [后序遍历](#后序遍历)
        * [层次遍历](#层次遍历)
            * [二叉树每层节点的平均值](#二叉树每层节点的平均值)
            * [得到左下角节点值](#得到左下角节点值)
    * [二叉查找树](#二叉查找树)
        * [有序数组构造二叉查找树](#有序数组构造二叉查找树)
        * [二叉查找树的最近公共祖先](#二叉查找树的最近公共祖先)
        * [二叉树的最近公共祖先](#二叉树的最近公共祖先)
        * [验证二叉查找树](#验证二叉查找树)
        * [二叉查找树中第k小的数](#二叉查找树中第k小的数)
    * [前缀树Trie](#前缀树Trie)
* [数组与矩阵](#数组与矩阵)
<!-- GFM-TOC -->

## 栈与队列

栈是一个只能从同一端插入或删除的线性表，是先进后出。插入删除端为栈顶，另一端为栈底。对于栈 [1, 2, 3, 4], 1 是栈底，4 是栈顶。  
队列是一个从一端插入，从另一端删除的线性表，是先进先出。插入端为队尾，删除端队头。对于队列 [4, 3, 2, 1], 1 是队尾，4 是队头。

### 用栈实现队列
[Leetcode : 232. Implement Queue using Stacks (Easy)](https://leetcode.com/problems/implement-queue-using-stacks/description/)

>Implement the following operations of a queue using stacks.  
push(x) -- Push element x to the back of queue.  
pop() -- Removes the element from in front of queue.  
peek() -- Get the front element.  
empty() -- Return whether the queue is empty.  
>  
>Notes:  
You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.  
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.  
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).

问题描述：用栈来实现队列，假设队列 q = [1, 2, 3, 4]，那么其在栈里面的顺序是 s = [4, 3, 2, 1]。push() 要在队列 q 的队尾增加一个元素， 则在栈 s 中应该在栈顶增加一个元素，变为 s = [x, 4, 3, 2, 1]，可以使用两个栈来实现，一个只进行入栈 push 操作，一个只进行出栈 pop 操作，因此只需要在 instack 中追加元素 x 即可实现；pop() 删除队头元素 1，而在栈 s 中 1 是先进后出，因此可以将其全部 push 到 outstack 中，再取出栈顶元素即可。  
  
push() 时间复杂度 o(1)  
pop(), peek() 时间复杂度 o(n)

```python
class MyQueue:
    def __init__(self):
        self.instack, self.outstack = [],[]

    def push(self, x):
        self.instack.append(x)

    def pop(self):
        self.in2out()
        self.outstack.pop()
        
    def peek(self):
        self.in2out()
        return self.outstack[-1]
        
    def empty(self):
        return not self.instack and not self.outstack
    
    def in2out(self):
        if not self.outstack:
            while self.instack:
                self.outstack.append(self.instack.pop())
```

### 用队列实现栈
[Leetcode : 225. Implement Stack using Queues (Easy)](https://leetcode.com/problems/implement-stack-using-queues/description/)

```python
class MyStack:
    def __init__(self):
        self.queue = [] 

    def push(self, x):
        self.queue.append(x)

    def pop(self):
        for i in range(len(self.queue) - 1):
            self.queue.append(self.queue.pop(0))
        return self.queue.pop(0)

    def top(self):
        for i in range(len(self.queue) - 1):
            self.queue.append(self.queue.pop(0))
        result = self.queue[0]
        self.queue.append(self.queue.pop(0)) # 恢复原样
        return result

    def empty(self):
        return not self.queue
```

### 最小值栈
[Leetcode : 155. Min Stack (Easy)](https://leetcode.com/problems/min-stack/description/)

>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.  
push(x) -- Push element x onto stack.  
pop() -- Removes the element on top of the stack.  
top() -- Get the top element.  
getMin() -- Retrieve the minimum element in the stack.  

问题描述：题目要求得到最小值的时间复杂度为 o(1)，因此需要以空间换时间，可以使用两个栈来实现，一个栈存储原始数据，另一个栈存储最小值。

```python
class MinStack:
    def __init__(self):
        self.stack, self.minstack = [], []

    def push(self, x):
        self.stack.append(x)
        if not self.minstack or x <= self.minstack[-1]:  #1
            self.minstack.append(x)
        
    def pop(self):
        if self.minstack and self.minstack[-1] == self.top():
            self.minstack.pop()
        self.stack.pop()

    def top(self):
        return self.stack[-1]
       
    def getMin(self):
        return self.minstack[-1]
```

备注： 1. 必须要是 x <= self.minstack[-1]，重复元素也应该加到 minstack 中，否则在删除时会删除唯一的 min 值。

### 用栈实现括号匹配
[Leetcode : 20. Valid Parentheses (Easy)](https://leetcode.com/problems/valid-parentheses/description/)

>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.  
The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

思路：栈最典型的应用即验证配对情况，对一个有效的括号对，左括号必定在右括号前面，因此可以将所有的左括号入栈，遇到匹配的右括号就将栈顶的括号消除，必定会有至少一对括号在 s 中是相邻的，因此一直消除栈顶，如果遇到不匹配的括号，直接返回 False，但栈为空时，即没有左括号，此时仍有右括号，则返回 False，最后所有字符都遍历完成后，栈为空则返回 True， 栈非空返回 Flase。  
  
可以利用 dict 来存储括号对，从而提高代码效率。  
  
时间复杂度为 o(n), 空间复杂度为 o(n)。

```python
def is_valid(s):
    stack = []
    dict = {'(': ')', '[': ']', '{': '}'}
    for c in s:
        if c in dict:
            stack.append(c)
        elif len(stack) == 0 or dict[stack.pop()] != c:
            return False
    return not stack
```

## 哈希表
python 的内建数据类型字典是用哈希表来实现的，使用哈希表可以快速查找一个元素是否存在，但需要一定的存储空间。因此在优先考虑时间复杂度的情况下，可以使用哈希表来以空间换时间。  
  
>**字典 dict 的遍历**  
遍历 key 值：for key in dict  
遍历 value 值：for value in dict.values()  
遍历字典项：for kv in dict.items()  
遍历 key 和 value 值 : for key, value in dict.items()  
>  
>dict.get(key) : 返回指定键的值，不存在则返回 None  
dict.has_key(key) : 键在字典中返回 true，否则 false  
dict.pop(key) ：删除该 key 和 value

### 两数之和
[Leetcode : 1. Two Sum (Easy)](https://leetcode.com/problems/two-sum/description/)

>Given an array of integers, return indices of the two numbers such that they add up to a specific target.  
You may assume that each input would have exactly one solution, and you may not use the same element twice.  
>  
>Example:  
Given nums = [2, 7, 11, 15], target = 9,  
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].

思路：使用字典来存储数组元素和索引的映射，将 nums[i] 和 i 存储到 dict 中，遍历一遍数组，若 target - nums[i] 在 dict 中，则直接返回两个数的下标。  
  
时间复杂度为 o(n)，空间复杂度为 o(n)

```python
def twoSum(nums, target):
    dic = {}
    if len(nums) <= 1:
        return false
    for i in range(len(nums)):
        tmp = target - nums[i]
        if tmp in dic:
            return [dic[tmp], i]
        else:
            dic[nums[i]] = i
```

### 同构字符串
[Leetcode : 205. Isomorphic Strings (Easy)](https://leetcode.com/problems/isomorphic-strings/description/)

>Given two strings s and t, determine if they are isomorphic.  
Two strings are isomorphic if the characters in s can be replaced to get t.  
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.  
>  
>For example,  
Given "egg", "add", return true.  
Given "foo", "bar", return false.  
Given "paper", "title", return true.  
Note:  
You may assume both s and t have the same length.  

问题描述：判断两个字符串是否是同构字符串，如果一个字符串 s 中的字符可以替换成别的字符，从而得到另一个字符串 t，则 s 和 t 是同构字符串。并且 s 中的所有相同字符都要被替换，保持原来的顺序，两个不同的字符不可以替换成相同的字符，字符也可以不替换。  
  
思路：用字典来存储 s[i] 和 t[i]，将第一个字符串 s 的字符作为 key，第二个字符串 t 的字符作为 value，遍历一遍数组，有两种情况：  
1. 当 s[i] 在 dic 中时，s[i] 的 value 不等于 t[i] 时，则直接返回 False，相等则继续遍历。  
2. 当 s[i] 不在 dic 中时，若此时对应的 t[i] 却在 dic 的 values 中，则表明已经有一个 key 对应了这个 t[i]，现在 s[i] 对应的字符也是 t[i]，由于不能有两个不同的字符对应同一个字符，因此返回 False；否则将这一对 s[i] 作为 key，t[i] 作为 value 存入 dic 中。

```python
def isIsomorphic(self, s, t):
    dic = {}
    for i in range(len(s)):
        if s[i] in dic:
            if t[i] != dic[s[i]]:
                return False 
        else:
            if t[i] in dic.values():
                return False
            dic[s[i]] = t[i]
    return True
```

### 最长和谐序列
[Leetcode : 594. Longest Harmonious Subsequence (Easy)](https://leetcode.com/problems/longest-harmonious-subsequence/description/)

>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.  
Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.  
>  
>Input: [1,3,2,2,5,2,3,7]  
Output: 5  
Explanation: The longest harmonious subsequence is [3,2,2,2,3].  
Note: The length of the input array will not exceed 20,000.  

问题描述：找出数组中的最长和谐序列，其最大数和最小数之间只相差 1。  
  
思路：在最长和谐序列中，只可能出现两种数字，这两个数字之间相差 1，因此可以先对 nums 进行计数，得到 nums[i]：count[i] 的一个字典，遍历该字典，对每个 key 判断 key+1 是否在其中，并返回次数和的最大值。

```python
def find_LHS(nums):
    dict = collections.Counter(nums)
    output = 0
    for key in dict:
        if key + 1 in dict:
           output = max(output, dict[key] + dict[key+1])
    return output
```

>备注：python 标准库 collections 模块中的 Counter 类，用于跟踪值出现的次数，以字典的键对值形式进行存储，元素作为 key，其计数作为 value。

## 数组与矩阵

## 二叉树
二叉树（Binary Tree）是 n 个节点的有限集合，该集合可以为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 
  
### 递归
二叉树是一种递归结构，很多问题可以使用递归解决。  
  
下面各题中对于二叉树的定义：
```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

#### 二叉树的高度
[Leetcode : 104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

>Given a binary tree, find its maximum depth.  
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

问题描述： 求二叉树的高度，利用递归计算，返回左子树和右子树中较大的深度，再加上 1 作为原二叉树的深度。  
  
时间复杂度为 o(n)

```python
class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

#### 二叉树的最小高度
[Leetcode : 111. Minimum Depth of Binary Tree (Easy)](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)

>Given a binary tree, find its minimum depth.  
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

思路：简单思考有四种情况
1. 空树，返回 0
2. 只有右子树，返回右子树高度
3. 只有左子树，返回左子树高度
4. 左右子树都有，返回左右子树高度的较小值

```python
class Solution:
    def minDepth(self, root):
        if not root:
            return 0
        if not root.left and root.right:
            return self.minDepth(root.right) + 1
        if not root.right and root.left:
            return self.minDepth(root.left) + 1
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

#### 反转二叉树
[Leetcode : 226. Invert Binary Tree (Easy)](https://leetcode.com/problems/invert-binary-tree/description/)

```html
Invert a binary tree.  
     4  
   /   \  
  2     7  
 / \   / \  
1   3 6   9  
to  
     4  
   /   \  
  7     2  
 / \   / \  
9   6 3   1
```

思路：反转二叉树，对于一个节点 root 而言，只需要将其左孩子和右孩子交换即可实现反转，递归调用即可。

```python
class Solution:
    def invertTree(self, root):
        if not root:
            return None
        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)        
        return root
```

#### 归并二叉树
[Leetcode : 617. Merge Two Binary Trees (Easy)](https://leetcode.com/problems/merge-two-binary-trees/description/)

>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.  
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.  

```html
Input:  
    Tree 1                     Tree 2  
          1                         2  
         / \                       / \  
        3   2                     1   3  
       /                           \   \  
      5                             4   7  
Output:  
Merged tree:  
         3  
        / \  
       4   5  
      / \   \  
     5   4   7
```

思路：
```python
def mergeTrees(self, t1, t2):
    if not t1 and not t2:
        return None
    if not t1:
        return t2
    if not t2:
        return t1
    root = TreeNode(t1.val + t2.val)
    root.left = self.mergeTrees(t1.left, t2.left)
    root.right = self.mergeTrees(t1.right, t2.right)
        
    return root
```

#### 路径和
[Leetcdoe : 112. Path Sum (Easy)](https://leetcode.com/problems/path-sum/description/)

>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.  
```html
Given the below binary tree and sum = 22,
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

思路：利用递归实现，如果根节点为空，则直接返回 False，如果到最后都没有出现 sum == 0 的情况时，再进行一轮递归，则 root == None， 因此也返回 False。必须要注意的是最后的返回一定是递归的结果，当 sum == 0 并且该节点为叶子节点时才返回 True。

```python
class Solution:
    def hasPathSum(self, root, sum):
        if not root:
            return False
        sum -= root.val
        if sum == 0 and not root.left and not root.right:
            return True
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)
```

#### 对称树
[Leetcode : 101. Symmetric Tree (Easy)](https://leetcode.com/problems/symmetric-tree/description/)

```html
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

思路： 由于输入只有 root，而判断对称树需要比较左右节点是否相等，因此可以构造一个辅助函数 symmetric 来比较左右节点的值。  
1. 终止条件是已经到了叶子节点，即 left == None and right == None  
2. 当左右节点的值相等时，继续递归比较左节点的左子树与右节点的右子树是否相等，以及左节点的右子树与右节点的左子树是否相等。

```python
class Solution:
    def isSymmetric(self, root):
        if not root:
            return True # 空树为对称树
        return self.symmetric(root.left, root.right)
         
    def symmetric(self, left, right):
        if not left and not right:
            return True
        if left and right and left.val == right.val:
            return self.symmetric(left.left, right.right) and self.symmetric(left.right, right.left)
        else:
            return False
```

#### 平衡二叉树
[Leetcode : 110. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)

>Given a binary tree, determine if it is height-balanced.  
For this problem, a height-balanced binary tree is defined as:  
a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

```html
Given the following tree [3,9,20,null,null,15,7]:
    3
   / \
  9  20
    /  \
   15   7
Return true.

Given the following tree [1,2,2,3,3,null,null,4,4]:
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
```

思路：平衡二叉树是二叉树的任意节点的两颗子树之间的高度差小于等于 1。对于平衡二叉树，其左子树和右子树也是平衡二叉树，因此可以递归判断。需要构造一个函数来求二叉树的高度，可以用之前的 maxDepth。  
1. 终止条件：当左子树和右子树的最大高度相差 1 时，返回 False  
2. 继续递归调用 isBalanced, 判断 root.left 和 root.right 是不是平衡二叉树。

```python
class Solution:
    def isBalanced(self, root):
        if not root:
            return True
        if abs(self.maxDepth(root.left) - self.maxDepth(root.right)) > 1:
            return False
        return self.isBalanced(root.left) and self.isBalanced(root.right)
        
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### 遍历
```html
    1
   / \
  2   3
 / \   \
4   5   6
```
1. 层次遍历，[1, 2, 3, 4, 5, 6]
2. 前序遍历（根左右），[1, 2, 4, 5, 3, 6]
3. 中序遍历（左根右），[4, 2, 5, 1, 3, 6]
4. 后序遍历（左右根），[4, 5, 2, 6, 3, 1]  
层次遍历使用 **广度优先搜索 BFS** 实现，  
前中后序遍历使用 **深度优先搜索 DFS** 实现。

#### 前序遍历
[Leetcode : 144. Binary Tree Preorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

>Given a binary tree, return the inorder traversal of its nodes' values.

递归实现
```python
class Solution(object):
    def __init__(self):
        self.result = []
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root:
            self.result.append(root.val)
            self.preorderTraversal(root.left)
            self.preorderTraversal(root.right)
        return self.result
```
  
非递归实现：  
利用堆栈，用迭代来实现二叉树的前序遍历，一直将左子树进栈，root->left->right
1. 当根节点存在时，保存根节点的值，并将根节点入栈
2. 将根节点指向左子树
3. 当根节点不存在时（即没有左子树），栈顶元素出栈，并将根节点指向栈顶元素的右子树
4. 循环 123 步

>总结：  
非空：访问，进栈，向左走  
空：出栈，向右走

```python
class Solution(object):
    def preorderTraversal(self, root):
        result = []
        stack = []
        while root or stack:
            while root:
                result.append(root.val)
                stack.append(root)
                root = root.left
            if stack:
                node = stack.pop()
                root = node.right
        return result
```

#### 中序遍历
[Leetcode : 94. Binary Tree Inorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

非递归实现：  
中序遍历同样利用堆栈实现，堆栈定义与前序遍历相同。left->root->right
1. 当根节点存在时，将根节点入栈，并将根节点指向左子树
2. 当根节点不存在时（即没有左子树），栈顶元素出栈，保存栈顶元素的值（第一次即最左节点），并将根节点指向栈顶元素的右子树

```python
class Solution(object):
    def inorderTraversal(self, root):
        result = []
        stack = []
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            if stack:
                node = stack.pop()
                result.append(node.val)
                root = node.right
        return result
```

#### 后序遍历
[Leetcode : 145. Binary Tree Postorder Traversal (Hard)](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)

非递归实现：  
后序遍历同样利用堆栈实现，left->right->root，可以通过 root->right->left 的结果逆序输出得到，即与前序遍历相似

```python
class Solution(object):
    def postorderTraversal(self, root):
        result = []
        stack = []
        while root or stack:
            while root:
                result.append(root.val)
                stack.append(root)
                root = root.right
            if stack:
                node = stack.pop()
                root = node.left
        return result[::-1]
```

#### 层次遍历
[Leetcode : 102. Binary Tree Level Order Traversal (Medium)](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

```html
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```

思路：层次遍历利用队列的先进先出特性，将先进入队列的元素 pop 出来。  
题中需要按照层次来打印出遍历结果，可以用一个临时列表存储二叉树一层的所有节点。即用 queue 来存储当前层元素， tmp 存储下一层元素。

```python
class Solution(object):
    def levelOrder(self, root):
        result = []
        if not root:
            return result
        queue = [root]
        while queue:
            result.append([node.val for node in queue])
            tmp = []
            for node in queue:
                if node.left:
                    tmp.append(node.left)
                if node.right:
                    tmp.append(node.right)
            queue = tmp
        return result
```

#### 二叉树每层节点的平均值
[637. Average of Levels in Binary Tree (Easy)](https://leetcode.com/problems/average-of-levels-in-binary-tree/description/)

>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.

```html
Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].
```

```python
class Solution(object):
    def averageOfLevels(self, root):
        result = []
        queue = [root]
        while queue:
            tmp = []
            sum = 0.0
            for node in queue:
                sum += node.val
                if node.left:
                    tmp.append(node.left)
                if node.right:
                    tmp.append(node.right)
            result.append(sum/len(queue))
            queue = tmp
        return result
```

#### 得到左下角节点值
[Leetcode : 513. Find Bottom Left Tree Value (Medium)](https://leetcode.com/problems/find-bottom-left-tree-value/description/)

>Given a binary tree, find the leftmost value in the last row of the tree.  
Note: You may assume the tree (i.e., the given root node) is not NULL.

```html
Input:
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
```

思路：利用层次遍历，记录下每一层的元素，返回最后一层的第一个元素即可。

```python
class Solution(object):
    def findBottomLeftValue(self, root):
        queue = [root]
        result = root
        while queue:
            tmp = []
            result = queue[0]
            for node in queue:
                if node.left:
                    tmp.append(node.left)
                if node.right:
                    tmp.append(node.right)
            queue = tmp
        return result.val
```

### 二叉查找树
二叉查找树（BST），又称二叉排序树、二叉搜索树。
1. 没有键值相等的节点
2. 若**左子树**不为空，则左子树上节点值**均小于**根节点的值
3. 若**右子树**不为空，则右子树上节点值**均大于**根节点的值
4. 任意节点的左、右子树也是二叉查找树

二叉查找树中序遍历一遍的结果是单调递增的，可以用于二分搜索。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 o(logn)，但当二叉查找树退化为单链表时，查找效率最低，最低为 o(n)。

#### 有序数组构造二叉查找树
[Leetcode : 108. Convert Sorted Array to Binary Search Tree (Easy)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/)

>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.  
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

```html
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:
      0
     / \
   -3   9
   /   /
 -10  5
```

思路：BST 二叉查找树即 left < root < right，因此利用有序数组构造 BST，且需要满足平衡二叉树的定义，注意到题中只要求给出一种解法，因此可以利用数组中间的数来作为 root，该数左边的用来构造左子树，右边的构造右子树，即将数组分成三个部分， [0, mid-1], mid, [mid+1, len(nums)-1]，再递归产生左右子树即可。

```python
class Solution:
    def sortedArrayToBST(self, nums):
        if len(nums) == 0:
            return None
        return self.toBST(nums, 0, len(nums)-1)
        
    def toBST(self, nums, start, end):
        if start > end:
            return None
        mid = (start + end) // 2 
        root = TreeNode(nums[mid])
        root.left = self.toBST(nums, start, mid - 1)
        root.right = self.toBST(nums, mid + 1, end)
        return root
```

#### 二叉查找树的最近公共祖先
[Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree (Easy)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.  
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”  
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

```html
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
```

思路：由于二叉查找树的左子树节点的值小于根节点，右子树节点的值大于根节点，因此可以从根节点出发递归判断。
1. 若 root 的值大于 p 和 q 的值，则 LCA 在左子树
2. 若 root 的值小于 p 和 q 的值，则 LCA 在右子树
3. 若 root 的值介于 p 和 q 之间，则 root 就是 LCA

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```

#### 二叉树的最近公共祖先
[Leetcode : 236. Lowest Common Ancestor of a Binary Tree (Medium) ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.  
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”  
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

```html
        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
```

思路：重点在于找到节点 p 和 q 在左子树还是右子树
1. 若当前结点为空或者与 p 和 q 一致，则返回该节点
2. 递归寻找 p 和 q 在左、右子树的位置
3. 若 p 和 q 分别在左、右子树上，则返回 root，否则就在左、右子树上

```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p ,q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        if left:
            return left
        return right
```

#### 验证二叉查找树
[Leetcode : 98. Validate Binary Search Tree (Medium)](https://leetcode.com/problems/validate-binary-search-tree/description/)

>Given a binary tree, determine if it is a valid binary search tree (BST).  
Assume a BST is defined as follows:  
The left subtree of a node contains only nodes with keys less than the node's key.  
The right subtree of a node contains only nodes with keys greater than the node's key.  
Both the left and right subtrees must also be binary search trees.

```html
    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
```

思路：利用 BST 中序遍历是有序数组的特点来求解，只要当前节点的值小于或等于上一个节点的值，则直接返回 False，当遍历完成后返回 True

```python
class Solution(object):
    def isValidBST(self, root):
        if not root or (not root.left and not root.right):
            return True
        stack = []
        pre_val = float('-inf')
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            if stack:
                node = stack.pop()
                if node.val <= pre_val:
                    return False
                pre_val = node.val
                root = node.right
        return True
```

#### 二叉查找树中第k小的数
[Leetcode : 230. Kth Smallest Element in a BST (Medium)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/)

>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.  
Note:   
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.  
Follow up:  
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?

思路：利用中序遍历，当遍历到第 k 个数时返回当前节点的值。

```python
class Solution(object):
    def kthSmallest(self, root, k):
        stack =[]
        count = 0
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            if stack:
                node = stack.pop()
                count += 1
                if count == k:
                    return node.val
                root = node.right
```

### 前缀树Trie
Trie，又称前缀树或字典树，是一种有序树状的数据结构，用于保存关联数组，其中的键通常是字符串。

<div align="center"><img src="../../pics/trie.jpg"></div>

####实现 Trie
[Leetcode : 208. Implement Trie (Prefix Tree) (Medium)](https://leetcode.com/problems/implement-trie-prefix-tree/description/)

>Implement a trie with insert, search, and startsWith methods.  
Note:  
You may assume that all inputs are consist of lowercase letters a-z.

