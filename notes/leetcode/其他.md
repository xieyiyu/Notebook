# 其他

<!-- GFM-TOC -->
* [两数之和](#两数之和)
* [最长回文子串](#最长回文子串)
* [最长公共前缀](#最长公共前缀)
* [有序数组删除重复元素](#有序数组删除重复元素)
* [删除元素](#删除元素)
* [实现strStr()](#实现strStr())
* [最后单词的长度](#最后单词的长度)
* [Plus One](#plus-one)
* [二进制相加](#二进制相加)
<!-- GFM-TOC -->

### 两数之和
[Leetcode : 2. Add Two Numbers(Medium)](https://leetcode.com/problems/add-two-numbers/description/)

>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  
You may assume the two numbers do not contain any leading zero, except the number 0 itself.  
>  
>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
Output: 7 -> 0 -> 8  
Explanation: 342 + 465 = 807.

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        num1 = num2 = 0
        tens = 1
        while l1 or l2:
            if l1:
                num1 = num1 + l1.val * tens
                l1 = l1.next
            if l2:
                num2 = num2 + l2.val * tens
                l2 = l2.next
            tens = tens * 10
      
        sum = num1 + num2
        
        p = head = ListNode(sum%10)
        sum = sum // 10
        while sum:
            node = ListNode(sum%10)
            p.next = node
            p = node
            sum = sum // 10            
        return head
```

### 最长回文子串
[Leetcode : 5. Longest Palindromic Substring(Medium)](https://leetcode.com/problems/longest-palindromic-substring/description/)

>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  
>  
>Input: "babad"  
Output: "bab"  
Note: "aba" is also a valid answer.

### 最长公共前缀
[Leetcode : 14. Longest Common Prefix(Easy)](https://leetcode.com/problems/longest-common-prefix/description/)

>Write a function to find the longest common prefix string amongst an array of strings.  
If there is no common prefix, return an empty string "".  
>  
>Input: ["flower","flow","flight"]  
Output: "fl"

```python
def longestCommonPrefix(strs):
    if not strs:
        return prefix
    for j in range(len(strs[0])):
        x = strs[0][j]
        for i in range(len(strs)):
            if len(strs[i]) <= j or strs[i][j] != x:
                return prefix
        prefix += x
    return prefix
```

### 有序数组删除重复元素
[Leetcode : 26. Remove Duplicates from Sorted Array(Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  
>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。  
时间复杂度 o(n), 空间复杂度 o(1)

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j
```

### 删除元素
[Leetcode : 27. Remove Element(Easy)](https://leetcode.com/problems/remove-element/description/)

>Given an array nums and a value val, remove all instances of that value in-place and return the new length.  
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  
The order of elements can be changed. It doesn't matter what you leave beyond the new length.

思路：与上一题相同

```python
def removeElement(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j
```

### 实现strStr()
[Leetcode : 28. Implement strStr()(Easy)](https://leetcode.com/problems/implement-strstr/description/)

>Implement strStr().  
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.  
>  
>Input: haystack = "hello", needle = "ll"  
Output: 2  
Input: haystack = "aaaaa", needle = "bba"  
Output: -1

```python

```

### 最后单词的长度
[Leetcode : 58. Length of Last Word(Easy)](https://leetcode.com/problems/length-of-last-word/description/)

>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.  
If the last word does not exist, return 0.  
Note: A word is defined as a character sequence consists of non-space characters only.  
>  
>Input: "Hello World"  
Output: 5

思路：由于字符串 s 只包含空格和字母，因此可以先去除 s 首尾的空格，再从后往前计算最后一个单词的长度。

```python
def lengthOfLastWord(s):
    s = s.strip()
    if not s:
        return 0
    cnt = 0
    for i in range(len(s)-1, -1, -1):
        if s[i].isspace():
            break
        cnt += 1
    return cnt
```

### Plus One
[Leetcode : 66. Plus One(Easy)](https://leetcode.com/problems/plus-one/description/)

>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.  
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.  
You may assume the integer does not contain any leading zero, except the number 0 itself.  
>  
Input: [1,2,3]  
Output: [1,2,4]  
Explanation: The array represents the integer 123.

```python
def plusOne(digits):
    sum = 0
    tens = 1
    for i in range(len(digits)-1, -1, -1):
        sum += digits[i] * tens
        tens *= 10
    sum += 1
    newnum = []
    for s in str(sum):
        newnum.append(int(s))
    return newnum
```

效率改进：可以先将 list 转为 str，再将该 str 转为 int + 1，再将其变为 str，append 到新的 newnum中。

### 二进制相加
[Leetcode : 67. Add Binary(Easy)](https://leetcode.com/problems/add-binary/description/)

>Given two binary strings, return their sum (also a binary string).  
The input strings are both non-empty and contains only characters 1 or 0.  
>  
>Input: a = "1010", b = "1011"  
Output: "10101"

```python

```
