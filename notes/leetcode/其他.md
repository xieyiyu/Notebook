# 其他

<!-- GFM-TOC -->
* [字符串](#字符串)
    * [6. ZigZag Conversion](#zigzag-conversion)
    * [8. String to Integer](#string-to-integer)
    * [14. 最长公共前缀](#最长公共前缀)
    * [28. 实现strStr()](#实现strStr())
    * [38. Count and Say](#count-and-say)
    * [49. Group Anagrams](#group-anagrams)
    * [58. 最后单词的长度](#最后单词的长度)
    * [71. Simplify Path](#simplify-path)
    * [125. 验证回文字符串](#验证回文字符串)
    * [151. Reverse Words in a String](#reverse-words-in-a-string)
    * [165. Compare Version Numbers](#compare-version-numbers)
* [双指针](#双指针)
    * [11. Container With Most Water](#container-with-most-water)
    * [15. 3Sum](#3sum)
    * [16. 3Sum Closest](#3sum-closest)
    * [18. 4Sum](#4sum)
* [其他](#其他)
    * [2. 两数之和](#两数之和)
    * [26. 有序数组删除重复元素](#有序数组删除重复元素)
    * [27. 删除元素](#删除元素)
    * [136. 数组中的单数字](#数组中的单数字)
    * [168. Excel Sheet Column Title](#excel-sheet-column-title)

<!-- GFM-TOC -->
## 字符串
### ZigZag Conversion
[Leetcode : 6. ZigZag Conversion(Medium)](https://leetcode.com/problems/zigzag-conversion/description/)

```python
def convert(self, s, numRows):
    if len(s) <= 1 or numRows <= 1:
        return s
    res = ''
    n = 0
    for i in range(numRows, 0, -1):
        j = n
        while j < len(s):
            res += s[j]
            j = j + 2*i - 2
            if i == 1:
                j = j + 2 * numRows -2 # 最后一行和第一行的步长相同
            if j < len(s) and i != 1  and i != numRows: # 不是第一行或最后一行，就不需要改变步长
                res += s[j]
                j = j + 2*(numRows-i+1) - 2
        n += 1
    return res
```

### String to Integer
[Leetcode : 8. String to Integer (atoi)(Medium)](https://leetcode.com/problems/string-to-integer-atoi/description/)

```python
def myAtoi(self, str):
    str = str.strip(' ')
    flag = 1
    if not str:
        return 0
    if len(str) == 1 and not str.isdigit():
        return 0
    if str[0] == '-' and str[1].isdigit():
        flag = -1
        str = str[1:]
    if str[0] == '+':
        str = str[1:]
    if not str[0].isdigit():
        return 0
    digit = ''
    for i in str:
        if i.isdigit():
            digit += i
        else:
            break
            
    res = int(digit) * flag
    if res <= 2147483647 and res >= -2147483648: 
        return res
    elif res > 2147483647:
        return 2147483647
    else:
        return -2147483648
```

### 最长公共前缀
[Leetcode : 14. Longest Common Prefix(Easy)](https://leetcode.com/problems/longest-common-prefix/description/)

```python
def longestCommonPrefix(strs):
    if not strs:
        return prefix
    for j in range(len(strs[0])):
        x = strs[0][j]
        for i in range(len(strs)):
            if len(strs[i]) <= j or strs[i][j] != x:
                return prefix
        prefix += x
    return prefix
```

### 实现strStr()
[Leetcode : 28. Implement strStr()(Easy)](https://leetcode.com/problems/implement-strstr/description/)

思路：利用 python 的切片判断是否是 needle 相等。  
python 中判断字符串 str2 是否是 str1 的子串：  
str1.find(str2) # 是：返回index， 否： 返回 -1  
str2 in str1  

```python
def strStr(haystack, needle):
    if not needle:
        return 0
    h = len(haystack)
    n = len(needle)
    if h < n:
        return -1
    for i in range(h-n+1):
        if haystack[i:i+n] == needle:
            return i
    return -1
```

### Count and Say
[Leetcode : 38. Count and Say (Easy)](https://leetcode.com/problems/count-and-say/description/)

思路： 设计一个函数，输入一个字符串，得到满足规则的下一个字符串，然后循环递归该函数得到结果即可。 一个一个字符判断，如果是相同字符，则 count+1，当遇到不同的字符时，则将前一个字符的次数和字符加到 res 中。

```python
def countAndSay(self, n):
    """
    :type n: int
    :rtype: str
    """
    res = '1'
    while n > 1:
        res = self.countStr(res)
        n -= 1
    return res
    
def countStr(self, s):
    res = ""
    count = 0
    tmp = s[0]
    for char in s:
        if char == tmp:
            count += 1
        else:
            res += str(count) + tmp
            tmp = char
            count = 1
    res += str(count) + tmp
    return res
```

### Group Anagrams
[Leetcode : 49. Group Anagrams (Medium)](https://leetcode.com/problems/group-anagrams/description/)

问题描述： 将字符及其个数相等的字符串放在一组中。  
思路： 对每个字符串进行排序，设置一个字典存储所有排序后的字符串，然后再判断每个原始字符串排序后时候存在于字典中。

```python
def groupAnagrams(self, strs):
    res, dic = [], []
    for word in strs:
        s = sorted(word)
        if s in dic:
            i = dic.index(s)
            res[i].append(word)
        else:
            dic.append(s)
            res.append([word])
    return res
```

### 最后单词的长度
[Leetcode : 58. Length of Last Word(Easy)](https://leetcode.com/problems/length-of-last-word/description/)

思路：由于字符串 s 只包含空格和字母，因此可以先去除 s 首尾的空格，再从后往前计算最后一个单词的长度。

```python
def lengthOfLastWord(s):
    s = s.strip()
    if not s:
        return 0
    cnt = 0
    for i in range(len(s)-1, -1, -1):
        if s[i].isspace():
            break
        cnt += 1
    return cnt
```

### Simplify Path
[Leetcode : 71. Simplify Path (Medium)](https://leetcode.com/problems/simplify-path/description/)

要注意的是，当有三个及三个以上的 '.' 出现时，如 '...' 或 '...abc' 时，这当做普通字符。  
利用堆栈，当遇到 '.' 或 '.' 时，则不管； 遇到 '..' 时，若此时 stack 非空，则出栈，stack 空，则不操作； 其余情况都进栈。

```python
def simplifyPath(self, path):
    stack = []
    path_list = path.split('/')
    for p in path_list:
        if p == '.' or not p:
            continue
        if p == '..':
            if stack:
                stack.pop()
        else:
            stack.append(p)
    return '/' + '/'.join(stack)
```

### 验证回文字符串
[Leetcode : 125. Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/description/)

思路：利用正则表达式替换掉非字母或数字的字符，然后直接比较反转后的字符串
```python
import re
class Solution(object):
    def isPalindrome(self, s):
        s = re.sub('\W+', '', s)
        s = s.lower()
        return s == s[::-1]
```

### Reverse Words in a String
[Leetcode : 151. Reverse Words in a String (Medium)](https://leetcode.com/problems/reverse-words-in-a-string/description/)

一开始想的比较复杂，自己去切割字符串，构造列表；实际上直接用 split 即可将空格给切分开。代码简洁。

```python
def reverseWords(self, s):
    res = s.split()
    return ' '.join(res[::-1])
```

### Compare Version Numbers
[Leetcode : 165. Compare Version Numbers (Medium)](https://leetcode.com/problems/compare-version-numbers/description/)

思路： 先根据 '.' 来划分字符串，得到 v1 和 v2，将 v1 和 v2 填充为相等的长度； 之后开始遍历，利用 int() 将字符串转为整数，可以去掉字符串开头的字符 0，如 '001' 就变为了 1；之后再比较字符串，判断 version 的大小。 

```python
def compareVersion(self, version1, version2):
    if version1 == version2:
        return 0
    v1 = version1.split('.')
    v2 = version2.split('.')
    if len(v1) < len(v2):
        v1 += ['0'] * (len(v2) - len(v1))
    elif len(v1) > len(v2):
        v2 += ['0'] * (len(v1) - len(v2))

    for i in range(len(v1)):
        v1[i], v2[i] = int(v1[i]), int(v2[i])
        if v1[i] > v2[i]:
            return 1
        elif v1[i] < v2[i]:
            return -1
    return 0
```

## 其他
### 两数之和
[Leetcode : 2. Add Two Numbers(Medium)](https://leetcode.com/problems/add-two-numbers/description/)

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        num1 = num2 = 0
        tens = 1
        while l1 or l2:
            if l1:
                num1 = num1 + l1.val * tens
                l1 = l1.next
            if l2:
                num2 = num2 + l2.val * tens
                l2 = l2.next
            tens = tens * 10
      
        sum = num1 + num2
        
        p = head = ListNode(sum%10)
        sum = sum // 10
        while sum:
            node = ListNode(sum%10)
            p.next = node
            p = node
            sum = sum // 10            
        return head
```

### 有序数组删除重复元素
[Leetcode : 26. Remove Duplicates from Sorted Array(Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。  
时间复杂度 o(n), 空间复杂度 o(1)

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j
```

### 删除元素
[Leetcode : 27. Remove Element(Easy)](https://leetcode.com/problems/remove-element/description/)

思路：与上一题相同

```python
def removeElement(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j
```

### 数组中的单数字
[Leetocde : 136. Single Number(Easy)](https://leetcode.com/problems/single-number/description/)

思路：用哈希表来记录数字及其出现的次数

```python
def singleNumber(nums):
    cnt = {}
    for num in nums:
        if num not in cnt:
            cnt[num] = 1
        else:
            cnt[num] += 1
    for num, count in cnt.items():
        if count == 1:
            return num
```

### Excel Sheet Column Title
[Leetcode : 168. Excel Sheet Column Title(Easy)](https://leetcode.com/problems/excel-sheet-column-title/description/)

相当于是将十进制变为二十六进制表示，但要注意的是 A 代表的是 1，没有 0  

```python
class Solution:
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        res = ''
        while n:
            res = chr((n-1)%26 + 65) + res # chr()返回整数对应的 ascii 字符，大写字母 A 为 65
            n = (n-1) // 26 # 由于没有 0，记得要减一
        return res
```

## 双指针
### Container With Most Water
[Leetcode : 11. Container With Most Water (Medium)](https://leetcode.com/problems/container-with-most-water/description/)

直接暴力解法两层循环会超时，考虑双指针求解，left 和 right 指向左右两边的柱子，保留较高的柱子，移动较矮的柱子。

```python
def maxArea(self, height):
    left, right = 0, len(height)-1
    max_area = 0
    while left < right:
        area = (right-left) * min(height[left], height[right])
        max_area = max(max_area, area)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

### 3Sum
[Leetcode : 15. 3Sum (Medium)](https://leetcode.com/problems/3sum/description/)

思路： 先固定一个数字，然后用双指针 left 和 right 分别从前后扫描，判断三个数的和是否等于 0。  
需要注意的是要去除重复的答案，固定的数字只需要取相等数字的第一个，左指针指向相等数字的最右边一个，右指针指向相等数字的最左边一个。 如果不跳过重复的数字的话，会超时。  

```python
def threeSum(self, nums):
    res = []
    if len(nums) < 3:
        return res
    nums = sorted(nums)
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]: # 只需要用到重复数的第一个数字，之后的跳过
            continue
        left = i + 1
        right = len(nums) - 1
        while left < right:
            sum = nums[i] + nums[left] + nums[right]
            if sum < 0:
                left += 1
            elif sum > 0:
                right -= 1
            else:
                res.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1  
    return res
```

### 3Sum Closest
[Leetcode : 16. 3Sum Closest (Medium)](https://leetcode.com/problems/3sum-closest/description/)

### 4Sum
[Leetcode : 18. 4Sum (Medium)](https://leetcode.com/problems/4sum/description/)