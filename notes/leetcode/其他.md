# 其他

<!-- GFM-TOC -->
* [字符串](#字符串)
    * [6. ZigZag Conversion](#zigzag-conversion)
    * [8. String to Integer](#string-to-integer)
    * [14. 最长公共前缀](#最长公共前缀)
    * [28. 实现strStr()](#实现strStr())
    * [38. Count and Say](#count-and-say)
    * [49. Group Anagrams](#group-anagrams)
    * [58. 最后单词的长度](#最后单词的长度)
    * [71. Simplify Path](#simplify-path)
    * [125. 验证回文字符串](#验证回文字符串)
    * [151. Reverse Words in a String](#reverse-words-in-a-string)
* [其他](#其他)
    * [2. 两数之和](#两数之和)
    * [26. 有序数组删除重复元素](#有序数组删除重复元素)
    * [27. 删除元素](#删除元素)
    * [136. 数组中的单数字](#数组中的单数字)
    * [168. Excel Sheet Column Title](#excel-sheet-column-title)

<!-- GFM-TOC -->
## 字符串
### ZigZag Conversion
[Leetcode : 6. ZigZag Conversion(Medium)](https://leetcode.com/problems/zigzag-conversion/description/)

```html
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P   A   H   N
A P L S I I G
Y   I   R
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

```python
def convert(self, s, numRows):
    if len(s) <= 1 or numRows <= 1:
        return s
    res = ''
    n = 0
    for i in range(numRows, 0, -1):
        j = n
        while j < len(s):
            res += s[j]
            j = j + 2*i - 2
            if i == 1:
                j = j + 2 * numRows -2 # 最后一行和第一行的步长相同
            if j < len(s) and i != 1  and i != numRows: # 不是第一行或最后一行，就不需要改变步长
                res += s[j]
                j = j + 2*(numRows-i+1) - 2
        n += 1
    return res
```

### String to Integer
[Leetcode : 8. String to Integer (atoi)(Medium)](https://leetcode.com/problems/string-to-integer-atoi/description/)

```python
def myAtoi(self, str):
    str = str.strip(' ')
    flag = 1
    if not str:
        return 0
    if len(str) == 1 and not str.isdigit():
        return 0
    if str[0] == '-' and str[1].isdigit():
        flag = -1
        str = str[1:]
    if str[0] == '+':
        str = str[1:]
    if not str[0].isdigit():
        return 0
    digit = ''
    for i in str:
        if i.isdigit():
            digit += i
        else:
            break
            
    res = int(digit) * flag
    if res <= 2147483647 and res >= -2147483648: 
        return res
    elif res > 2147483647:
        return 2147483647
    else:
        return -2147483648
```

### 最长公共前缀
[Leetcode : 14. Longest Common Prefix(Easy)](https://leetcode.com/problems/longest-common-prefix/description/)

>Write a function to find the longest common prefix string amongst an array of strings.  
If there is no common prefix, return an empty string "".  
>  
>Input: ["flower","flow","flight"]  
Output: "fl"

```python
def longestCommonPrefix(strs):
    if not strs:
        return prefix
    for j in range(len(strs[0])):
        x = strs[0][j]
        for i in range(len(strs)):
            if len(strs[i]) <= j or strs[i][j] != x:
                return prefix
        prefix += x
    return prefix
```

### 实现strStr()
[Leetcode : 28. Implement strStr()(Easy)](https://leetcode.com/problems/implement-strstr/description/)

>Implement strStr().  
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.  
>  
>Input: haystack = "hello", needle = "ll"  
Output: 2  
Input: haystack = "aaaaa", needle = "bba"  
Output: -1

思路：利用 python 的切片判断是否是 needle 相等。  
python 中判断字符串 str2 是否是 str1 的子串：  
str1.find(str2) # 是：返回index， 否： 返回 -1  
str2 in str1  

```python
def strStr(haystack, needle):
    if not needle:
        return 0
    h = len(haystack)
    n = len(needle)
    if h < n:
        return -1
    for i in range(h-n+1):
        if haystack[i:i+n] == needle:
            return i
    return -1
```

### Count and Say
[Leetcode : 38. Count and Say (Easy)](https://leetcode.com/problems/count-and-say/description/)

思路： 设计一个函数，输入一个字符串，得到满足规则的下一个字符串，然后循环递归该函数得到结果即可。 一个一个字符判断，如果是相同字符，则 count+1，当遇到不同的字符时，则将前一个字符的次数和字符加到 res 中。

```python
def countAndSay(self, n):
    """
    :type n: int
    :rtype: str
    """
    res = '1'
    while n > 1:
        res = self.countStr(res)
        n -= 1
    return res
    
def countStr(self, s):
    res = ""
    count = 0
    tmp = s[0]
    for char in s:
        if char == tmp:
            count += 1
        else:
            res += str(count) + tmp
            tmp = char
            count = 1
    res += str(count) + tmp
    return res
```

### Group Anagrams
[Leetcode : 49. Group Anagrams (Medium)](https://leetcode.com/problems/group-anagrams/description/)

问题描述： 将字符及其个数相等的字符串放在一组中。  
思路： 对每个字符串进行排序，设置一个字典存储所有排序后的字符串，然后再判断每个原始字符串排序后时候存在于字典中。

```python
def groupAnagrams(self, strs):
    res, dic = [], []
    for word in strs:
        s = sorted(word)
        if s in dic:
            i = dic.index(s)
            res[i].append(word)
        else:
            dic.append(s)
            res.append([word])
    return res
```

### 最后单词的长度
[Leetcode : 58. Length of Last Word(Easy)](https://leetcode.com/problems/length-of-last-word/description/)

>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.  
If the last word does not exist, return 0.  
Note: A word is defined as a character sequence consists of non-space characters only.  
>  
>Input: "Hello World"  
Output: 5

思路：由于字符串 s 只包含空格和字母，因此可以先去除 s 首尾的空格，再从后往前计算最后一个单词的长度。

```python
def lengthOfLastWord(s):
    s = s.strip()
    if not s:
        return 0
    cnt = 0
    for i in range(len(s)-1, -1, -1):
        if s[i].isspace():
            break
        cnt += 1
    return cnt
```

### Simplify Path
[Leetcode : 71. Simplify Path (Medium)](https://leetcode.com/problems/simplify-path/description/)

要注意的是，当有三个及三个以上的 '.' 出现时，如 '...' 或 '...abc' 时，这当做普通字符。  
利用堆栈，当遇到 '.' 或 '.' 时，则不管； 遇到 '..' 时，若此时 stack 非空，则出栈，stack 空，则不操作； 其余情况都进栈。

```python
def simplifyPath(self, path):
    stack = []
    path_list = path.split('/')
    for p in path_list:
        if p == '.' or not p:
            continue
        if p == '..':
            if stack:
                stack.pop()
        else:
            stack.append(p)
    return '/' + '/'.join(stack)
```

### 验证回文字符串
[Leetcode : 125. Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/description/)

>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.  
Note: For the purpose of this problem, we define empty string as valid palindrome.  
>  
>Input: "A man, a plan, a canal: Panama"  
Output: true

思路：利用正则表达式替换掉非字母或数字的字符，然后直接比较反转后的字符串
```python
import re
class Solution(object):
    def isPalindrome(self, s):
        s = re.sub('\W+', '', s)
        s = s.lower()
        return s == s[::-1]
```

### Reverse Words in a String
[Leetcode : 151. Reverse Words in a String (Medium)](https://leetcode.com/problems/reverse-words-in-a-string/description/)

一开始想的比较复杂，自己去切割字符串，构造列表；实际上直接用 split 即可将空格给切分开。代码简洁。

```python
def reverseWords(self, s):
    res = s.split()
    return ' '.join(res[::-1])
```

## 其他
### 两数之和
[Leetcode : 2. Add Two Numbers(Medium)](https://leetcode.com/problems/add-two-numbers/description/)

>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  
You may assume the two numbers do not contain any leading zero, except the number 0 itself.  
>  
>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
Output: 7 -> 0 -> 8  
Explanation: 342 + 465 = 807.

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        num1 = num2 = 0
        tens = 1
        while l1 or l2:
            if l1:
                num1 = num1 + l1.val * tens
                l1 = l1.next
            if l2:
                num2 = num2 + l2.val * tens
                l2 = l2.next
            tens = tens * 10
      
        sum = num1 + num2
        
        p = head = ListNode(sum%10)
        sum = sum // 10
        while sum:
            node = ListNode(sum%10)
            p.next = node
            p = node
            sum = sum // 10            
        return head
```

### 有序数组删除重复元素
[Leetcode : 26. Remove Duplicates from Sorted Array(Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  
>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。  
时间复杂度 o(n), 空间复杂度 o(1)

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j
```

### 删除元素
[Leetcode : 27. Remove Element(Easy)](https://leetcode.com/problems/remove-element/description/)

>Given an array nums and a value val, remove all instances of that value in-place and return the new length.  
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  
The order of elements can be changed. It doesn't matter what you leave beyond the new length.

思路：与上一题相同

```python
def removeElement(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j
```

### 数组中的单数字
[Leetocde : 136. Single Number(Easy)](https://leetcode.com/problems/single-number/description/)

>Given a non-empty array of integers, every element appears twice except for one. Find that single one.  
Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?  
>  
>Input: [4,1,2,1,2]  
Output: 4

思路：用哈希表来记录数字及其出现的次数

```python
def singleNumber(nums):
    cnt = {}
    for num in nums:
        if num not in cnt:
            cnt[num] = 1
        else:
            cnt[num] += 1
    for num, count in cnt.items():
        if count == 1:
            return num
```

### Excel Sheet Column Title
[Leetcode : 168. Excel Sheet Column Title(Easy)](https://leetcode.com/problems/excel-sheet-column-title/description/)

>Given a positive integer, return its corresponding column title as appear in an Excel sheet.

相当于是将十进制变为二十六进制表示，但要注意的是 A 代表的是 1，没有 0  

```python
class Solution:
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        res = ''
        while n:
            res = chr((n-1)%26 + 65) + res # chr()返回整数对应的 ascii 字符，大写字母 A 为 65
            n = (n-1) // 26 # 由于没有 0，记得要减一
        return res
```
