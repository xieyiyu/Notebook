# 其他

<!-- GFM-TOC -->
* [两数之和](#两数之和)
* [最长回文子串](#最长回文子串)
* [验证回文字符串](#验证回文字符串)
* [最长公共前缀](#最长公共前缀)
* [有序数组删除重复元素](#有序数组删除重复元素)
* [删除元素](#删除元素)
* [数组中的单数字](#数组中的单数字)
* [实现strStr()](#实现strStr())
* [最后单词的长度](#最后单词的长度)
* [Plus One](#plus-one)
* [二进制相加](#二进制相加)
* [Excel Sheet Column Title](#excel-sheet-column-title)
* [Rotate Array](#rotate-array)
<!-- GFM-TOC -->

### 两数之和
[Leetcode : 2. Add Two Numbers(Medium)](https://leetcode.com/problems/add-two-numbers/description/)

>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  
You may assume the two numbers do not contain any leading zero, except the number 0 itself.  
>  
>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
Output: 7 -> 0 -> 8  
Explanation: 342 + 465 = 807.

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        num1 = num2 = 0
        tens = 1
        while l1 or l2:
            if l1:
                num1 = num1 + l1.val * tens
                l1 = l1.next
            if l2:
                num2 = num2 + l2.val * tens
                l2 = l2.next
            tens = tens * 10
      
        sum = num1 + num2
        
        p = head = ListNode(sum%10)
        sum = sum // 10
        while sum:
            node = ListNode(sum%10)
            p.next = node
            p = node
            sum = sum // 10            
        return head
```

### 最长回文子串
[Leetcode : 5. Longest Palindromic Substring(Medium)](https://leetcode.com/problems/longest-palindromic-substring/description/)

>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  
>  
>Input: "babad"  
Output: "bab"  
Note: "aba" is also a valid answer.

### 验证回文字符串
[Leetcode : 125. Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/description/)

>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.  
Note: For the purpose of this problem, we define empty string as valid palindrome.  
>  
>Input: "A man, a plan, a canal: Panama"  
Output: true

思路：利用正则表达式替换掉非字母或数字的字符，然后直接比较反转后的字符串
```python
import re
class Solution(object):
    def isPalindrome(self, s):
        s = re.sub('\W+', '', s)
        s = s.lower()
        return s == s[::-1]
```

### 最长公共前缀
[Leetcode : 14. Longest Common Prefix(Easy)](https://leetcode.com/problems/longest-common-prefix/description/)

>Write a function to find the longest common prefix string amongst an array of strings.  
If there is no common prefix, return an empty string "".  
>  
>Input: ["flower","flow","flight"]  
Output: "fl"

```python
def longestCommonPrefix(strs):
    if not strs:
        return prefix
    for j in range(len(strs[0])):
        x = strs[0][j]
        for i in range(len(strs)):
            if len(strs[i]) <= j or strs[i][j] != x:
                return prefix
        prefix += x
    return prefix
```

### 有序数组删除重复元素
[Leetcode : 26. Remove Duplicates from Sorted Array(Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  
>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。  
时间复杂度 o(n), 空间复杂度 o(1)

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j
```

### 删除元素
[Leetcode : 27. Remove Element(Easy)](https://leetcode.com/problems/remove-element/description/)

>Given an array nums and a value val, remove all instances of that value in-place and return the new length.  
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  
The order of elements can be changed. It doesn't matter what you leave beyond the new length.

思路：与上一题相同

```python
def removeElement(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j
```

### 数组中的单数字
[Leetocde : 136. Single Number(Easy)](https://leetcode.com/problems/single-number/description/)

>Given a non-empty array of integers, every element appears twice except for one. Find that single one.  
Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?  
>  
>Input: [4,1,2,1,2]  
Output: 4

思路：用哈希表来记录数字及其出现的次数

```python
def singleNumber(nums):
    cnt = {}
    for num in nums:
        if num not in cnt:
            cnt[num] = 1
        else:
            cnt[num] += 1
    for num, count in cnt.items():
        if count == 1:
            return num
```

### 实现strStr()
[Leetcode : 28. Implement strStr()(Easy)](https://leetcode.com/problems/implement-strstr/description/)

>Implement strStr().  
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.  
>  
>Input: haystack = "hello", needle = "ll"  
Output: 2  
Input: haystack = "aaaaa", needle = "bba"  
Output: -1

思路：利用 python 的切片判断是否是 needle 相等。  
python 中判断字符串 str2 是否是 str1 的子串：  
str1.find(str2) # 是：返回index， 否： 返回 -1  
str2 in str1  

```python
def strStr(haystack, needle):
    if not needle:
        return 0
    h = len(haystack)
    n = len(needle)
    if h < n:
        return -1
    for i in range(h-n+1):
        if haystack[i:i+n] == needle:
            return i
    return -1
```

### 最后单词的长度
[Leetcode : 58. Length of Last Word(Easy)](https://leetcode.com/problems/length-of-last-word/description/)

>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.  
If the last word does not exist, return 0.  
Note: A word is defined as a character sequence consists of non-space characters only.  
>  
>Input: "Hello World"  
Output: 5

思路：由于字符串 s 只包含空格和字母，因此可以先去除 s 首尾的空格，再从后往前计算最后一个单词的长度。

```python
def lengthOfLastWord(s):
    s = s.strip()
    if not s:
        return 0
    cnt = 0
    for i in range(len(s)-1, -1, -1):
        if s[i].isspace():
            break
        cnt += 1
    return cnt
```

### Plus One
[Leetcode : 66. Plus One(Easy)](https://leetcode.com/problems/plus-one/description/)

>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.  
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.  
You may assume the integer does not contain any leading zero, except the number 0 itself.  
>  
Input: [1,2,3]  
Output: [1,2,4]  
Explanation: The array represents the integer 123.

```python
def plusOne(digits):
    sum = 0
    tens = 1
    for i in range(len(digits)-1, -1, -1):
        sum += digits[i] * tens
        tens *= 10
    sum += 1
    newnum = []
    for s in str(sum):
        newnum.append(int(s))
    return newnum
```

效率改进：可以先将 list 转为 str，再将该 str 转为 int + 1，再将其变为 str，append 到新的 newnum中。

### 二进制相加
[Leetcode : 67. Add Binary(Easy)](https://leetcode.com/problems/add-binary/description/)

>Given two binary strings, return their sum (also a binary string).  
The input strings are both non-empty and contains only characters 1 or 0.  
>  
>Input: a = "1010", b = "1011"  
Output: "10101"

```python

```

### Excel Sheet Column Title
[Leetcode : 168. Excel Sheet Column Title(Easy)](https://leetcode.com/problems/excel-sheet-column-title/description/)

>Given a positive integer, return its corresponding column title as appear in an Excel sheet.

相当于是将十进制变为二十六进制表示，但要注意的是 A 代表的是 1，没有 0  

```python
class Solution:
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        res = ''
        while n:
            res = chr((n-1)%26 + 65) + res # chr()返回整数对应的 ascii 字符，大写字母 A 为 65
            n = (n-1) // 26 # 由于没有 0，记得要减一
        return res
```

### Rotate Array
[Leetcode : 189. Rotate Array(Easy)](https://leetcode.com/problems/rotate-array/description/)

>Given an array, rotate the array to the right by k steps, where k is non-negative.  
>  
>Input: [1,2,3,4,5,6,7] and k = 3  
Output: [5,6,7,1,2,3,4]  
Explanation:  
rotate 1 steps to the right: [7,1,2,3,4,5,6]  
rotate 2 steps to the right: [6,7,1,2,3,4,5]  
rotate 3 steps to the right: [5,6,7,1,2,3,4]

思路: 要注意 k 可能会比 len(nums) 更大，因此先要取余数，除尽的部分相当于 nums 没改变  
要求原地操作，切片是一个原地操作  
时间复杂度 o(n)， 空间复杂度 o(n)

```python
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        k = k % len(nums)
        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]
```
