# 其他

### 两数之和
[Leetcode : 2. Add Two Numbers(Medium)](https://leetcode.com/problems/add-two-numbers/description/)

>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.  
You may assume the two numbers do not contain any leading zero, except the number 0 itself.  
>  
>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)  
Output: 7 -> 0 -> 8  
Explanation: 342 + 465 = 807.

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        num1 = num2 = 0
        tens = 1
        while l1 or l2:
            if l1:
                num1 = num1 + l1.val * tens
                l1 = l1.next
            if l2:
                num2 = num2 + l2.val * tens
                l2 = l2.next
            tens = tens * 10
      
        sum = num1 + num2
        
        p = head = ListNode(sum%10)
        sum = sum // 10
        while sum:
            node = ListNode(sum%10)
            p.next = node
            p = node
            sum = sum // 10            
        return head
```

### 最长回文子串
[Leetcode : 5. Longest Palindromic Substring(Medium)](https://leetcode.com/problems/longest-palindromic-substring/description/)

>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.  
>  
>Input: "babad"  
Output: "bab"  
Note: "aba" is also a valid answer.

### 最长公共前缀
[Leetcode : 14. Longest Common Prefix(Easy)](https://leetcode.com/problems/longest-common-prefix/description/)

>Write a function to find the longest common prefix string amongst an array of strings.  
If there is no common prefix, return an empty string "".  
>  
>Input: ["flower","flow","flight"]  
Output: "fl"

```python
def longestCommonPrefix(strs):
    if not strs:
        return prefix
    for j in range(len(strs[0])):
        x = strs[0][j]
        for i in range(len(strs)):
            if len(strs[i]) <= j or strs[i][j] != x:
                return prefix
        prefix += x
    return prefix
```

### 有序数组删除重复元素
[Leetcode : 26. Remove Duplicates from Sorted Array(Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  
>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。  
时间复杂度 o(n), 空间复杂度 o(1)

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j
```

### 删除元素
[Leetcode : 27. Remove Element(Easy)](https://leetcode.com/problems/remove-element/description/)

>Given an array nums and a value val, remove all instances of that value in-place and return the new length.  
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.  
The order of elements can be changed. It doesn't matter what you leave beyond the new length.

思路：与上一题相同

```python
def removeElement(nums, val):
    j = 0
    for i in range(len(nums)):
        if nums[i] != val:
            nums[j] = nums[i]
            j += 1
    return j
```

### 实现strStr()
[Leetcode : 28. Implement strStr()(Easy)](https://leetcode.com/problems/implement-strstr/description/)

>Implement strStr().  
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.  
>  
>Input: haystack = "hello", needle = "ll"  
Output: 2  
Input: haystack = "aaaaa", needle = "bba"  
Output: -1

```python

```