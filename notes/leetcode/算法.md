# 算法

## 字典序
字典序，就是按照字典中出现的先后顺序进行排序。

1. 单个字符
在计算机中，26 个字母及数字的字典序为：
```
'0' < '1' < '2' <... < '9' < 'A' < 'B' < ... < 'Z' < 'a' < 'b' < ... < 'z'
```

2. 多个字符
在计算机中，两个字符串比较大小，是按照从左到右的顺序进行比较，如果第 1 位相等，就比较第 2 位，直至有一位可以比较出大小来，则不再继续比较。

比如： 'ab' < 'ac', 'abc' < 'ac', 'abc' < 'abcd'

3. 全排列的字典序
给定多个字符，可以按照任意顺序进行排列，所有排列称为全排列。
每一种排列对应一个字符串，如果这些字符串按照字符串大小的顺序进行排序，那么就这种排序是基于字典序的全排列。

### 字典序第 k 小的数字
[Leetcode : 386. Lexicographical Numbers (Medium)](https://leetcode.com/problems/lexicographical-numbers/)
```
给定一个整数 n, 返回从 1 到 n 的字典顺序。
例如，给定 n = 13，返回 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，要求 O(n) 时间复杂度
```

思路：如果 n = 300
1. 从数字 1 开始，添加下一个字典序的数字，当 cur * 10 <= n 时，说明下一个数字是 1 10 100 这样的，直接 cur * 10
2. 当 cur * 10 > n 时，已经超过最大的数字，那么就变回上一个数字，然后在个位上 +1，比如 1000 > n 了，那么就从 100 开始，后面是 101, 102, 103 ..., 199
3. 当 cur == 200 时，应该从 2 开始，也就是要去掉 200 后面的 0，因此使用一个 while 循环得到最高位的数字。

n = 300 时， res = [1, 10, 100, 101, 102, ..., 199, 2, 20, 200, 201, ...299, 3, 30, 300, 31, 32, ... , 39, 4, 40, ..., 49, ..., 9, 90, 91, ..., 99]

```python
def lexicalOrder(n):
	cur = 1
	res = []
	for _ in range(n):
		res.append(cur)
		if cur * 10 <= n:
			cur *= 10
		else:
			if cur >= n:
				cur //= 10
			cur += 1
			while cur % 10 == 0:
				cur //= 10
	return res
```



