# 数学

<!-- GFM-TOC -->
* [幂函数](#幂函数)
* [整数分解](#整数分解)
* [判断回文数](#判断回文数)
* [反转整数](#反转整数)
* [整数转罗马数字](#整数转罗马数字)
* [罗马数字转整数](#罗马数字转整数)
* [数组中的单数字](#数组中的单数字)
* [实现strStr()](#实现strStr())
* [最后单词的长度](#最后单词的长度)
* [Plus One](#plus-one)
* [二进制相加](#二进制相加)
* [Excel Sheet Column Title](#excel-sheet-column-title)
<!-- GFM-TOC -->

## 幂函数
[Leetcode : 50. Pow(x, n) (Medium)](https://leetcode.com/problems/powx-n/description/)


### 整数分解
[Leetcode : 343. Integer Break (Medium)](https://leetcode.com/problems/integer-break/description/)

>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.  
For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).  
Note: You may assume that n is not less than 2 and not larger than 58.  
Hint: You may check the breaking results of n ranging from 7 to 10 to discover the regularities.

问题描述：将一个正数 n 分解为 x 个数相加的和，求这 x 个数的乘积的最大值。  
  
思考什么时候乘积会最大？两个数：ab <= (a+b)<sup>2</sup>/4, 当且仅当 a = b 时，等号成立，因此当 n 拆分为两个相等的数的和是，这两个数的乘积最大。  
  
扩展到 x 个数，**当把 n 拆分为 x 个相等的数时他们的乘积最大**， 则共有 n/x 个数，这些数的乘积为 f(n) = x<sup>(n/x)</sup>， 要求 f(n) 的最大值，则对其求导， 可知当 x = e 时 f(n) 取得极大值。  
  
题中规定 x 是整数，则取 e 最接近的 3，因此将 n 拆分成多个 3 相加，最后可能留下 2 或 4，将这些数相乘则得到 f(n) 的最大值。因此最后是一个幂运算，幂运算的时间复杂度为 **o(logn)**
  
备注： 按照 Hint，可以写出 3-10 的 f(n) 的最大值，找到规律，从而求解。

```python
def integer_break(n):
    if n <= 3:
        return n - 1
    product = 1
    while n > 4:
        product *= 3
        n -= 3
    return product * n
```

## 回文数

### 判断回文数
[Leetcode : 9. Palindrome Number (Easy)](https://leetcode.com/problems/palindrome-number/description/)

>Determine whether an integer is a palindrome. Do this without extra space.

思路：由于要求 o(1) 的空间复杂度，因此不能将整数转为字符串。考虑直接利用除法和余数反转整数

```python
def isPalindrome(x):
    if x < 0:
        return False
    y = 0
    tmp = x
    while tmp:
        y = y * 10 + tmp % 10
        tmp = tmp // 10
    return x == y
```

优化上述方法：只需要将原数字反转一半则可以判断是否为回文数，且个数位为 0 的非零整数一定不是回文数。

```python
def isPalindrome(x):
    if x < 0 or (x != 0 and x % 10 == 0):
        return False
    y = 0
    while x > y:
        y = y * 10 + x % 10
        x = x // 10
    return x == y or y // 10 == x
```

## 整数

### 反转整数
[Leetcode : 7. Reverse Integer (Easy)](https://leetcode.com/problems/reverse-integer/description/)

>Given a 32-bit signed integer, reverse digits of an integer.  
Example 1:  
Input: 123
Output: 321  
>  
>Example 2:  
Input: -123  
Output: -321  
>  
>Example 3:  
Input: 120  
Output: 21  
>  
>Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>,  2<sup>31</sup> − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

思路：设置一个 flag 来控制最后的结果是正数还是负数。

```python
def reverse(x):
    flag = 1
    if x < 0:
        flag = -1
    x = abs(x)
    y = 0
    while x:
        y = y * 10 + x % 10
        x = x // 10
    y = flag * y 
    if y > 2**31-1 or y < -2**31:
        return 0
    return y
```

### 整数转罗马数字
[Leetcode : 12. Integer to Roman (Medium)](https://leetcode.com/problems/integer-to-roman/description/)

```python
def intToRoman(num):
    M = ['', 'M', 'MM', 'MMM']
    C = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']
    X = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']
    I = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']
    roman = M[num//1000] + C[num%1000//100] + X[num%100//10] + I[num%10]
    return roman
```

### 罗马数字转整数
[Leetcode : 13. Roman to Integer (Easy)](https://leetcode.com/problems/roman-to-integer/description/)

>For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.  
>  
>Note:  
I can be placed before V (5) and X (10) to make 4 and 9.   
X can be placed before L (50) and C (100) to make 40 and 90.   
C can be placed before D (500) and M (1000) to make 400 and 900.  
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

思路：如果没出现特殊情况，那么前面的字符值一定是大于等于后面的字符值的。因此若前一位字符值比当前字符值更小时，则出现了 IV,IX 的情况，此时只需要使结果减去两次前一位字符的值即可。

```python
def romanToInt(s):
    dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    sum = 0
    for i in range(len(s)):
        if i >= 1 and dict[s[i]] > dict[s[i-1]]:
            sum = sum - 2 * dict[s[i-1]]
        sum += dict[s[i]]
    return sum
```

### 阶乘0的个数
[Leetcode : 172. Factorial Trailing Zeroes (Easy)](https://leetcode.com/problems/factorial-trailing-zeroes/description/)

>Given an integer n, return the number of trailing zeroes in n!.  
Note: Your solution should be in logarithmic time complexity.  
>  
>Input: 3  
Output: 0  
Explanation: 3! = 6, no trailing zero.

思路： 末尾的 0 是由 2X5 来的，有多少个 2X5 则有多少个 0。  在阶乘中 2 的个数肯定是足够的，所以就看 n 分解出来有多少个 5 即可， 即有 n/5 个；  
但要注意的是 25 是两个 5， 125 是三个 5，因此最后 0 的个数为： n/5 + n/5/5 + n/5/5/5 + ...

```python
def trailingZeroes(self, n):
    res = 0
    while n:
        n = n // 5
        res += n
    return res
```
