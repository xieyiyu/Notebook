# 数学

<!-- GFM-TOC -->
* [幂函数](#幂函数)
* [整数分解](#整数分解)
* [判断回文数](#判断回文数)
* [反转整数](#反转整数)
* [整数转罗马数字](#整数转罗马数字)
* [罗马数字转整数](#罗马数字转整数)
* [阶乘0的个数](#阶乘0的个数)
* [Plus One](#plus-one)
* [二进制相加](#二进制相加)
* [Permutation Sequence](#permutation-sequence)
<!-- GFM-TOC -->

## 幂函数
[Leetcode : 50. Pow(x, n) (Medium)](https://leetcode.com/problems/powx-n/description/)

利用递归和二分法，将时间复杂度降到 log(n)。 降幂不断除 2，当遇到奇数时，将 幂-1 再继续除 2。

```python
def myPow(self, x, n):
    if n == 0:
        return 1
    if n < 0:
        return self.myPow(1/x, -n)
    if n == 2:
        return x*x
    if n % 2 == 0:
        return self.myPow(self.myPow(x, n/2), 2)
    else:
        return x * self.myPow(self.myPow(x, (n-1)/2), 2)
```

### 整数分解
[Leetcode : 343. Integer Break (Medium)](https://leetcode.com/problems/integer-break/description/)

>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.  
For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).  
Note: You may assume that n is not less than 2 and not larger than 58.  
Hint: You may check the breaking results of n ranging from 7 to 10 to discover the regularities.

问题描述：将一个正数 n 分解为 x 个数相加的和，求这 x 个数的乘积的最大值。  
  
思考什么时候乘积会最大？两个数：ab <= (a+b)<sup>2</sup>/4, 当且仅当 a = b 时，等号成立，因此当 n 拆分为两个相等的数的和是，这两个数的乘积最大。  
  
扩展到 x 个数，**当把 n 拆分为 x 个相等的数时他们的乘积最大**， 则共有 n/x 个数，这些数的乘积为 f(n) = x<sup>(n/x)</sup>， 要求 f(n) 的最大值，则对其求导， 可知当 x = e 时 f(n) 取得极大值。  
  
题中规定 x 是整数，则取 e 最接近的 3，因此将 n 拆分成多个 3 相加，最后可能留下 2 或 4，将这些数相乘则得到 f(n) 的最大值。因此最后是一个幂运算，幂运算的时间复杂度为 **o(logn)**
  
备注： 按照 Hint，可以写出 3-10 的 f(n) 的最大值，找到规律，从而求解。

```python
def integer_break(n):
    if n <= 3:
        return n - 1
    product = 1
    while n > 4:
        product *= 3
        n -= 3
    return product * n
```

## 回文数

### 判断回文数
[Leetcode : 9. Palindrome Number (Easy)](https://leetcode.com/problems/palindrome-number/description/)

>Determine whether an integer is a palindrome. Do this without extra space.

思路：由于要求 o(1) 的空间复杂度，因此不能将整数转为字符串。考虑直接利用除法和余数反转整数

```python
def isPalindrome(x):
    if x < 0:
        return False
    y = 0
    tmp = x
    while tmp:
        y = y * 10 + tmp % 10
        tmp = tmp // 10
    return x == y
```

优化上述方法：只需要将原数字反转一半则可以判断是否为回文数，且个数位为 0 的非零整数一定不是回文数。

```python
def isPalindrome(x):
    if x < 0 or (x != 0 and x % 10 == 0):
        return False
    y = 0
    while x > y:
        y = y * 10 + x % 10
        x = x // 10
    return x == y or y // 10 == x
```

## 整数

### 反转整数
[Leetcode : 7. Reverse Integer (Easy)](https://leetcode.com/problems/reverse-integer/description/)

>Given a 32-bit signed integer, reverse digits of an integer.  
Example 1:  
Input: 123
Output: 321  
>  
>Example 2:  
Input: -123  
Output: -321  
>  
>Example 3:  
Input: 120  
Output: 21  
>  
>Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>,  2<sup>31</sup> − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

思路：设置一个 flag 来控制最后的结果是正数还是负数。

```python
def reverse(x):
    flag = 1
    if x < 0:
        flag = -1
    x = abs(x)
    y = 0
    while x:
        y = y * 10 + x % 10
        x = x // 10
    y = flag * y 
    if y > 2**31-1 or y < -2**31:
        return 0
    return y
```

### 整数转罗马数字
[Leetcode : 12. Integer to Roman (Medium)](https://leetcode.com/problems/integer-to-roman/description/)

```python
def intToRoman(num):
    M = ['', 'M', 'MM', 'MMM']
    C = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']
    X = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']
    I = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']
    roman = M[num//1000] + C[num%1000//100] + X[num%100//10] + I[num%10]
    return roman
```

### 罗马数字转整数
[Leetcode : 13. Roman to Integer (Easy)](https://leetcode.com/problems/roman-to-integer/description/)

>For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.  
>  
>Note:  
I can be placed before V (5) and X (10) to make 4 and 9.   
X can be placed before L (50) and C (100) to make 40 and 90.   
C can be placed before D (500) and M (1000) to make 400 and 900.  
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

思路：如果没出现特殊情况，那么前面的字符值一定是大于等于后面的字符值的。因此若前一位字符值比当前字符值更小时，则出现了 IV,IX 的情况，此时只需要使结果减去两次前一位字符的值即可。

```python
def romanToInt(s):
    dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    sum = 0
    for i in range(len(s)):
        if i >= 1 and dict[s[i]] > dict[s[i-1]]:
            sum = sum - 2 * dict[s[i-1]]
        sum += dict[s[i]]
    return sum
```

### 阶乘0的个数
[Leetcode : 172. Factorial Trailing Zeroes (Easy)](https://leetcode.com/problems/factorial-trailing-zeroes/description/)

>Given an integer n, return the number of trailing zeroes in n!.  
Note: Your solution should be in logarithmic time complexity.  
>  
>Input: 3  
Output: 0  
Explanation: 3! = 6, no trailing zero.

思路： 末尾的 0 是由 2X5 来的，有多少个 2X5 则有多少个 0。  在阶乘中 2 的个数肯定是足够的，所以就看 n 分解出来有多少个 5 即可， 即有 n/5 个；  
但要注意的是 25 是两个 5， 125 是三个 5，因此最后 0 的个数为： n/5 + n/5/5 + n/5/5/5 + ...

```python
def trailingZeroes(self, n):
    res = 0
    while n:
        n = n // 5
        res += n
    return res
```

### Plus One
[Leetcode : 66. Plus One(Easy)](https://leetcode.com/problems/plus-one/description/)

>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.  
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.  
You may assume the integer does not contain any leading zero, except the number 0 itself.  
>  
Input: [1,2,3]  
Output: [1,2,4]  
Explanation: The array represents the integer 123.

```python
def plusOne(digits):
    sum = 0
    tens = 1
    for i in range(len(digits)-1, -1, -1):
        sum += digits[i] * tens
        tens *= 10
    sum += 1
    newnum = []
    for s in str(sum):
        newnum.append(int(s))
    return newnum
```

效率改进：可以先将 list 转为 str，再将该 str 转为 int + 1，再将其变为 str，append 到新的 newnum中。

### 二进制相加
[Leetcode : 67. Add Binary(Easy)](https://leetcode.com/problems/add-binary/description/)

>Given two binary strings, return their sum (also a binary string).  
The input strings are both non-empty and contains only characters 1 or 0.  
>  
>Input: a = "1010", b = "1011"  
Output: "10101"

思路：暴力解法，给更短的字符串的前面补足 0 ，然后按照二进制相加规则给两个字符串相加，最终得到的结果需要翻转字符串。  
  
简单解法：return str(bin(int(a, 2) + int(b,2)))[2:]  
bin() 返回一个整数 int 或者长整数 long int 的二进制表示。 前面会带上'0bxxx'，因此字符串返回为[2:]

```python
def addBinary(self, a, b):
    res = ''
    if len(a) < len(b):
        a, b = b, a
    b = '0'*(len(a)-len(b)) + b
    flag = 0
    for i in range(len(b)-1, -1, -1):
        sum = int(a[i]) + int(b[i]) + flag
        if sum == 2:
            res += '0'
            flag = 1
        elif sum == 3:
            res += '1'
            flag = 1
        else:
            res += str(sum) 
            flag = 0
    if flag == 1:
        res += '1'
    return res[::-1]
```

### Permutation Sequence
[Leetcode : 60. Permutation Sequence (Medium)](https://leetcode.com/problems/permutation-sequence/description/)

>The set [1,2,3,...,n] contains a total of n! unique permutations.  
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:
>  
>Input: n = 3, k = 3  
Output: "213"

```html
思路：  
假如有四位数[1, 2, 3, 4], 找 k=9 的序列，那么产生的所有排列为：  
1 + [2, 3, 4]
2 + [1, 3, 4]
3 + [1, 2, 4]
4 + [1, 2, 3]
其中，每组都有 3!=6 种可能，要找到 k=9 的，必定开头是 2，因此可以一位一位的来判断是哪个数字。
要得到第 k 个排列，其在数组中的下标应该是 k-1，必须要 k-1，否则最后一位顺序会颠倒
该数字被选出之后，必须在数组中删除该数字
```

```python
def getPermutation(self, n, k):
    res = ''
    nums = [i for i in range(1, n+1)]
    s = 1
    for i in range(1, n+1):
        s = s*i
    k -= 1
    while nums:
        s = s // n # 第一个数是 k // (n-1)!， 在剩余的 n-1 个数，要找出第 k % (n-1)! 个排列
        j = k // s # 选出的数
        k = k % s # 从剩下的数组中选出第几个排列
        res += str(nums[j])
        nums.pop(j)
        n -= 1
    return res
```