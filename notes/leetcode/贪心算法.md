# 贪心算法

贪心算法保证每次操作的局部最优解，从而得到全局最优，需要将求解的问题分成若干个子问题。

### 分配饼干
[Leetcode : 455. Assign Cookies (Easy)](https://leetcode.com/problems/assign-cookies/description/)

```html
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. 
Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. 
If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
Note:
You may assume the greed factor is always positive. You cannot assign more than one cookie to one child.

Input: [1,2,3], [1,1]
Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
```

问题描述：gi最小的孩子最容易满足，因此先用最小的sj与最小的gi比较，从而使饼干能够满足更多的孩子

```python
def assign_cookies(children_g, cookies_s):
    g_sort = sorted(children_g)
    s_sort = sorted(cookies_s)
    i=0
    j=0
    while(i<len(g_sort) and j<len(s_sort)):
        if(g_sort[i] <= s_sort[j]):
            i += 1
        j += 1
    return i
```

### 最少数量的箭引爆气球
[Leetcode : 452. Minimum Number of Arrows to Burst Balloons (Medium)](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

```html
There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.
An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.

Input:
[[10,16], [2,8], [1,6], [7,12]]
Output:
2
Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
```

问题描述：气球水平摆放，可以重叠，飞镖垂直射向坐标轴，可以将重叠区间内的气球全部刺破，求能使所有气球刺破的最小飞镖数
可以先对points进行排序，按照start从小到大，start相同时按照end，若第一个的end大于第二个的start，则两个可以一起刺破，然后更新end为两个之中较小的end，与第三个的start进行比较。

```python
def find_min_arrow(points):
    if len(points) ==0:  #1
        return 0
    points = sorted(points, key=lambda x: (x[0], x[1]))
    arrow = 1
    end = points[0][1]
    for i in range(1, len(points)):
        if(end >= points[i][0]):
            end = min(end, points[i][1])
        else:
            arrow += 1
            end = points[i][1]
    return arrow
```

备注：
1. 注意必须先判断points的长度，若为0则返回0，若不判断，则输入空数组时会报错index out of range索引越界

### 股票最大收益
[Leetcode : 122. Best Time to Buy and Sell Stock II (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

```html
Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
```