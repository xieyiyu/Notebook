# 贪心算法

贪心算法保证每次操作的局部最优解，从而得到全局最优，需要将求解的问题分成若干个子问题。

### 分配饼干
[Leetcode : 455. Assign Cookies (Easy)](https://leetcode.com/problems/assign-cookies/description/)

>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.   
Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj.   
If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  
Note:  
You may assume the greed factor is always positive. You cannot assign more than one cookie to one child.  
>
>Input: [1,2,3], [1,1]  
Output: 1  
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.   
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.  
You need to output 1.

问题描述：gi 最小的孩子最容易满足，因此先用最小的 sj 与最小的 gi 比较，从而使饼干能够满足更多的孩子

```python
def assign_cookies(children_g, cookies_s):
    g_sort = sorted(children_g)
    s_sort = sorted(cookies_s)
    i=0
    j=0
    while(i<len(g_sort) and j<len(s_sort)):
        if(g_sort[i] <= s_sort[j]):
            i += 1
        j += 1
    return i
```

### 最少数量的箭引爆气球
[Leetcode : 452. Minimum Number of Arrows to Burst Balloons (Medium)](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.  
An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.
>
>Input: [[10,16], [2,8], [1,6], [7,12]]  
Output: 2  
Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).


问题描述：气球水平摆放，可以重叠，飞镖垂直射向坐标轴，可以将重叠区间内的气球全部刺破，求能使所有气球刺破的最小飞镖数  
可以先对 points 进行排序，按照 start 从小到大，start 相同时按照 end，若第一个的end大于第二个的 start，则两个可以一起刺破，然后更新 end 为两个之中较小的 end，与第三个的 start 进行比较。

```python
def find_min_arrow(points):
    if len(points) ==0:  #1
        return 0
    points = sorted(points, key=lambda x: (x[0], x[1]))
    arrow = 1
    end = points[0][1]
    for i in range(1, len(points)):
        if(end >= points[i][0]):
            end = min(end, points[i][1])
        else:
            arrow += 1
            end = points[i][1]
    return arrow
```

备注：
1. 注意必须先判断 points 的长度，若为 0 则返回 0 ，若不判断，则输入空数组时会报错 index out of range 索引越界

### 股票最大收益
[Leetcode : 122. Best Time to Buy and Sell Stock II (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

>Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times).   
However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

问题描述：找到股票价格 list 中的最大收益，只要有 price[i]<price[i-1] 时，就将其添加到 profit 中，局部最优可以保证全局最优

```python
def maxProfit(prices):
        profit = 0
        if len(prices) <= 1:
            return 0
        for i in range(0, len(prices)-1):
            if prices[i] < prices[i+1]:
                profit = profit + prices[i+1] - prices[i]
        return profit
```

### 种植花朵
[Leetcode : 605. Can Place Flowers (Easy)](https://leetcode.com/problems/can-place-flowers/description/)

>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.  
Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.  
>
>Input: flowerbed = [1,0,0,0,1], n = 1  
Output: True  
Note:  
The input array won't violate no-adjacent-flowers rule.  
The input array size is in the range of [1, 20000].  
n is a non-negative integer which won't exceed the input array size.

```python
def can_place_flowers(flowerbed, n):
    size = len(flowerbed)
    flowerbed.insert(0, 0)
    flowerbed.append(0)
    for i in range(1, size+1):
        if flowerbed[i] == 0 and flowerbed[i-1] == 0 and flowerbed[i+1] == 0:
            n = n - 1
            flowerbed[i] = 1
    if n<=0:
        return True
    else:
        return False
```

### 非递减数组
[Leetcode : 665. Non-decreasing Array (Easy)](https://leetcode.com/problems/non-decreasing-array/description/)

>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.We define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).
>
>Input: [4,2,3]  
Output: True  
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.

问题描述：最多修改一个数，使nums成为非递减数组。只要出现 nums[i] > nums[i+1], 则计数 +1，且修改此数，但本次修改**不能影响后面的操作**， 到底修改 nums[i] 还是 nums[i+1]，需要比较 nums[i+1] 和 nums[i-1]的大小

```python
def check_possibility(nums):
    if len(nums) == 1:
        return True
    cnt = 0
    if nums[0] > nums[1]:
        nums[0] = nums[1]
        cnt = 1
    for i in range(1, len(nums)-1):
        if nums[i] > nums[i+1]:
            if nums[i+1] <= nums[i-1]:
                nums[i+1] = nums[i]
            nums[i] = nums[i+1]
            cnt += 1
        if cnt == 2:
            return False
    return True
```

### 判断子串
[Leetcode : 392. Is Subsequence (Medium)](https://leetcode.com/problems/is-subsequence/description/)

>Given a string s and a string t, check if s is subsequence of t.  
You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).  
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).  
>  
>s = "abc", t = "ahbgdc"  
Return true.

```python
def is_subsequence(s, t):
    if len(s) > len(t):  #1
        return False
    for i in s:
        if i in t:
            index = t.find(i)
            t = t[index + 1:]
        else:
            return False
    return True
```
备注：1. s 为空时，也是 t 的子串

### 分隔字符串
[Leetcode : 763. Partition Labels (Medium)](https://leetcode.com/problems/partition-labels/description/)

>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.
>
>Input: S = "ababcbacadefegdehijhklij"  
Output: [9,7,8]  
Explanation:The partition is "ababcbaca", "defegde", "hijhklij".This is a partition so that each letter appears in at most one part.A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.  
Note:S will have length in range [1, 500].S will consist of lowercase letters ('a' to 'z') only.

问题描述：分割字符串，使得每个字母都只处于一个子串中，求最大的划分中每个子串的 size

```python
def partition_labels(S):
    end = S.rfind(S[0])
    array = []
    start = 0
    for i in range(0, len(S)):
        i_end = S.rfind(S[i]) #1
        end = max(end, i_end)
        if i == end:
            array.append(len(S[start:end+1]))
            start = i + 1
            end = end + 1
    return array
```

备注：
1. python 中的查找字符位置：find() 从字符串左边开始查询子字符串匹配到的第一个索引；rfind() 从字符串右边开始查询字符串匹配到的第一个索引
2. 用 range 实现 rfind：for i in range(len, -1, -1)
range(start, stop[, step]) 不包括step
3. 时间复杂度为 o(n<sup>2</sup>), 可以用空间换时间，先记录下每个字符最后出现的位置，空间复杂度为 o(n)，然后再遍历该数组，  
 last = {c: i for i, c in enumerate(S)}

### 按身高重组序列
[Leetcode : 406. Queue Reconstruction by Height(Medium)](https://leetcode.com/problems/queue-reconstruction-by-height/description/)

>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.  
Note:The number of people is less than 1,100.  
>
>Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  
Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

问题描述：为了在每次进行插入操作时，插入的数据不会影响后面的排列，则应该先排身高较高的人，否则若是先排身高较低的，之后的操作可能会将其从 k 变为 k+1 位置，即高个会影响矮个的位置。  
因此首先需要对原序列进行排序，按照第一个数降序，第二个数升序的原则，每次插入操作时，第二个数是几就将其插入到 result 的第几位。

```python
def reconstruct_queue(people):
    if len(people) == 0:
        return people
    people = sorted(people, key=lambda x: (-x[0], x[1]))
    result = []
    for person in people :
        result.insert(person[1], person)
    return result
```

