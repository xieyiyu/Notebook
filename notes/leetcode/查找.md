# 查找算法

## 二分查找
二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键词有序排列。 时间复杂度为 o(log(n))

```python
def binary_search(search_list, search_key):
    low = 0
    high = len(search_list) - 1
    while(low <= high):
        mid = low + (high-low)//2  #1#2
        print(mid)
        if(search_key == search_list[mid]):
            return mid
        elif(search_key < search_list[mid]):
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

需要注意的事项：
1. 计算 mid 时，使用其它语言（JAVA,C++）编写时，若采用 (low+high)//2 时存在溢出风险，int 最大值为 65535，超过后会变为负值，但 python 中不存在整数溢出问题； 
2. python3 中除法，/ 为真除法，带小数位，// 取整数位

### 求开方
[Leetcode : 69. Sqrt(x) (Easy)](https://leetcode.com/problems/sqrtx/description/)

>Implement int sqrt(int x).Compute and return the square root of x.x is guaranteed to be a non-negative integer.  
Input: 4  
Output: 2  
>
>Input: 8  
Output: 2  
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.


```python
def my_sqrt(x):
    if x<=1:
        return x
    elif x>1:
        low = 1
        high = x
        while (low <= high):
            mid = low + (high-low)//2
            sqrt = x // mid
            if sqrt == mid :
                return mid
            elif sqrt > mid:
                low = mid + 1
            else:
                high = mid - 1
        return high  #1
    else:
        return -1
```

备注：
1. 一个数 x>1 的开方必定在 1~x 之间，因此可以用二分查找来找到 sqrt
2. 由于返回的是整数，因此开方包含小数位时，找不到 sqrt==mid ，则返回开方的整数位

### 放置硬币
[Leetcode : 441. Arranging Coins (Easy)](https://leetcode.com/problems/arranging-coins/description/)

>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.  
Given n, find the total number of full staircase rows that can be formed.
n is a non-negative integer and fits within the range of a 32-bit signed integer.  
>
>n = 8  
The coins can form the following rows:  
¤  
¤ ¤  
¤ ¤ ¤  
¤ ¤  
Because the 4th row is incomplete, we return 3.

问题描述：1+2+...+x = n,则 x 为可以摆的层数，最后一层无法摆满时，不能计数。 

```python
def arrange_coins(n):
    if n < 0:
        return -1
    low = 0
    high = n
    while(low <= high):
        mid = low + (high-low)//2
        sum = mid * (1+mid) // 2
        if sum <= n and sum > n-mid:
            return mid
        elif sum > n:
            high = mid - 1
        else:
            low = mid + 1
```

### 有序数组的Single Element
[Leetcode : 540. Single Element in a Sorted Array (Medium)](https://leetcode.com/problems/single-element-in-a-sorted-array/description/)

>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.
Your solution should run in O(log n) time and O(1) space.
>
>Input: [3,3,7,7,10,11,11]  
Output: 10

问题描述：
1. 分三种情况，mid 刚好是 single；
2. single 在左侧，mid 是奇数，则 mid 左右均有奇数个数，若 nums[mid]==nums[mid+1]，右侧还有两个数，single 在左侧；mid 是偶数，则mid 左右均有偶数个数，若 nums[mid]==nums[mid-1]，则 single 在左侧；
3. single 在右侧。
4. 时间复杂度为 o(logn)，典型算法有三个：二分查找，欧几里得算法（求最大公约数），幂运算

```python
def single_element(nums):
    low = 0
    high = len(nums) - 1
    while(low < high): #1
        mid = low + (high-low)//2
        if(nums[mid] != nums[mid+1] and nums[mid]!= nums[mid-1]):
            return nums[mid]
        elif((mid%2 == 1 and nums[mid] == nums[mid+1]) or (mid%2 == 0 and nums[mid] == nums[mid-1])):
            high = mid -1
        else:
            low = mid + 1
    return nums[low]
```

备注：
1. 此处不能等于，否则会出现数组越界情况，如 nums=[1,1,2] 时
