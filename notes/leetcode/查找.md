# 查找算法
<!-- GFM-TOC -->
* [二分查找](#二分查找)
    * [33. 81. Search in Rotated Sorted Array](#search-in-rotated-sorted-array)
    * [34. Find First and Last Position of Element in Sorted Array](#find-first-and-last-position-of-element-in-sorted-array)
    * [69. 求开方](#求开方)
    * [441. 放置硬币](#放置硬币)
    * [540. 有序数组的Single Element](#有序数组的single-element)
<!-- GFM-TOC -->

## 二分查找
二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键词有序排列。 时间复杂度为 o(log(n))

```python
def binary_search(search_list, search_key):
    low = 0
    high = len(search_list) - 1
    while(low <= high):
        mid = low + (high-low)//2  #1#2
        print(mid)
        if(search_key == search_list[mid]):
            return mid
        elif(search_key < search_list[mid]):
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

需要注意的事项：
1. 计算 mid 时，使用其它语言（JAVA,C++）编写时，若采用 (low+high)//2 时存在溢出风险，int 最大值为 65535，超过后会变为负值，但 python 中不存在整数溢出问题； 
2. python3 中除法，/ 为真除法，带小数位，// 取整数位

### Search in Rotated Sorted Array
[Leetcode : 33. Search in Rotated Sorted Array (Medium)](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

在一个 rotate 的数组中找到目标数字的下标，但不知道 rotate 的位置在哪里，要求时间复杂度为 O(logn)，显然是二分查找。
利用二分查找来判断左右两边哪边的序列是有序的，若 nums[mid] 大于 nums[left]，则左边是有序的，若 nums[mid] 小于 nums[right]，则右边是有序的。
之后根据有序的半段来判断 num[mid] 是否在该区域中，来调整边界。

```python
def search(self, nums, target):
    left = 0
    right = len(nums)-1
    while left <= right:
        mid= left + (right-left) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        elif nums[mid] <= nums[right]:
            if target <= nums[right] and target > nums[mid]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### Search in Rotated Sorted Array II
[Leetcode : 81. Search in Rotated Sorted Array II (Medium)](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/)

与 33 不同的是，该题的数组可能有重复元素。 投机做法： return target in nums
该题比 33 多了一种情况，即可能出现 nums[mid] == nums[left], 此时无法判断 target 会在哪一边，因此只能够 left+1 往前走。其余的情况和上一题类似。

```python
def search(self, nums, target):
    left = 0
    right = len(nums)-1
    while left <= right:
        mid = left + (right-left) // 2
        if nums[mid] == target:
            return True
        elif nums[mid] == nums[left]:
            left += 1
        elif nums[mid] < nums[left]:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            if target < nums[mid] and target >= nums[left]:
                right = mid - 1
            else:
                left = mid + 1
    return False
```

### Find First and Last Position of Element in Sorted Array
[Leetcode : 34. Find First and Last Position of Element in Sorted Array (Medium)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

思路：先二分搜索找到位置，再根据该位置 index，循环判断 nums[index-1] 和 nums[index+1] 是否和 target 相等。

```python
def searchRange(self, nums, target):
    left = 0
    right = len(nums)-1
    index = -1
    while left <= right:
        mid = left + (right-left) // 2
        if nums[mid] == target:
            index = mid
            break
        elif target > nums[mid]:
            left = mid + 1
        else:
            right = mid - 1

    if index != -1:
        i = index - 1
        j = index + 1
        while i>=0 and nums[i] == target:
            i -= 1
        while j <= len(nums)-1 and nums[j] == target:
            j += 1
        return [i+1, j-1]
    else:
        return [-1, -1]
```

### 求开方
[Leetcode : 69. Sqrt(x) (Easy)](https://leetcode.com/problems/sqrtx/description/)

```python
def my_sqrt(x):
    if x<=1:
        return x
    elif x>1:
        low = 1
        high = x
        while (low <= high):
            mid = low + (high-low)//2
            sqrt = x // mid
            if sqrt == mid :
                return mid
            elif sqrt > mid:
                low = mid + 1
            else:
                high = mid - 1
        return high  #1
    else:
        return -1
```

备注：
1. 一个数 x>1 的开方必定在 1~x 之间，因此可以用二分查找来找到 sqrt
2. 由于返回的是整数，因此开方包含小数位时，找不到 sqrt==mid ，则返回开方的整数位

### 放置硬币
[Leetcode : 441. Arranging Coins (Easy)](https://leetcode.com/problems/arranging-coins/description/)

问题描述：1+2+...+x = n,则 x 为可以摆的层数，最后一层无法摆满时，不能计数。 

```python
def arrange_coins(n):
    if n < 0:
        return -1
    low = 0
    high = n
    while(low <= high):
        mid = low + (high-low)//2
        sum = mid * (1+mid) // 2
        if sum <= n and sum > n-mid:
            return mid
        elif sum > n:
            high = mid - 1
        else:
            low = mid + 1
```

### 有序数组的Single Element
[Leetcode : 540. Single Element in a Sorted Array (Medium)](https://leetcode.com/problems/single-element-in-a-sorted-array/description/)

问题描述：
1. 分三种情况，mid 刚好是 single；
2. single 在左侧，mid 是奇数，则 mid 左右均有奇数个数，若 nums[mid]==nums[mid+1]，右侧还有两个数，single 在左侧；mid 是偶数，则mid 左右均有偶数个数，若 nums[mid]==nums[mid-1]，则 single 在左侧；
3. single 在右侧。
4. 时间复杂度为 o(logn)，典型算法有三个：二分查找，欧几里得算法（求最大公约数），幂运算

```python
def single_element(nums):
    low = 0
    high = len(nums) - 1
    while(low < high): #1
        mid = low + (high-low)//2
        if(nums[mid] != nums[mid+1] and nums[mid]!= nums[mid-1]):
            return nums[mid]
        elif((mid%2 == 1 and nums[mid] == nums[mid+1]) or (mid%2 == 0 and nums[mid] == nums[mid-1])):
            high = mid -1
        else:
            low = mid + 1
    return nums[low]
```

备注：
1. 此处不能等于，否则会出现数组越界情况，如 nums=[1,1,2] 时，此时是由于第一种情况是，判断 nums[mid] != nums[mid+1] 时，当 mid 为 len(nums) - 1 时会造成数组越界。
