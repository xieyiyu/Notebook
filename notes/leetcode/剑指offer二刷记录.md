【总结】
Easy 会做：
1. 二维数组中的查找: target 与右上角数字对比来缩小范围，时间 O(n+m)，空间 O(1)
2. 重建二叉树：根据前序和中序构建，找到前序中根节点的位置将数组分为左右两部分，再递归，递归深度 O(logn)
3. 斐波那契数列： f(n) = f(n-1) + f(n-2)，f(0) = 0, f(1) = 1, f(2) = 1 注意初始值
4. 跳台阶： f(n) = f(n-1) + f(n-2)，f(1) = 1, f(2) = 2，与斐波拉切数列的初始值不同
5. 链表中倒数第k个结点： 快慢指针法，fast 先走 k 步，然后 fast 和 slow 同步走， 时间 O(n), 空间 O(1)
6. 反转链表： 设置 pre = None，从 cur = head 以此反转， 时间 O(n), 空间 O(1)
7. 二叉树的镜像： left 和 right 互换，再递归互换 left.left 和 right.right， 以及 left.right 和 right.left
8. 顺时针打印矩阵： 设置四个方向依次打印，注意每次打印都要判断 res 的长度是否已经超过矩阵大小
9. 从上往下打印二叉树： 层次遍历，cur 记录当前层的节点，tmp 记录下一层节点
10. 二叉树中和为某一值的路径： 回溯，注意递归结束的条件
11. 字符串的排列： 回溯，注意递归结束的条件，注意字符串拼接方法
12. 数组中出现次数超过一半的数字： 摩尔投票法，同加异减规则，当 cnt = 0 时，就重置要计数的数字并将 cnt = 1, 一次遍历完成，时间 O(n)，空间 O(1)，需要注意的是最后一定要检查得到的数字是否符合条件
13. 两个链表的第一个公共结点： 画图，当 p1 走到尾时就从 p2 的头部开始走，p2 走到尾时就从 p1 的头部开始走，时间 O(n+m)
14. 二叉树的深度： 递归，返回左右子树较大的深度 + 1
15. 平衡二叉树： 递归，左右子树的深度差 <= 1
16. 对称的二叉树： 递归，考虑清楚几种情况
17. 按之字形顺序打印二叉树： 层次遍历分奇数行和偶数行打印
18. 把二叉树打印成多行： 层次遍历
19. 二叉搜索树的第k个结点： 中序遍历

Medium 有思路，还需要再加深一遍：
1. 从尾到头打印链表： 自己是直接按顺序追加到 res 中，再 return res[::-1]，剑指 offer 是利用栈的后进先出特性来解决，用 stack 存储链表从头到尾的顺序，遍历完整个链表后，再将 stack 中的元素 pop 到 res 中

2. 用两个栈实现队列： 用 stack1 实现进队列，直接 append 元素到 stack1 中； stack2 实现出队列，首先要判断 stack2 中的是否有元素，stack2 为空，则把 stack1 中的元素全部压入 stack2 中，stack2 非空，则直接弹出 stack2 中的最后一个元素（栈顶）

3. 旋转数组的最小数字： 分情况考虑，因为从左边算过来后面肯定是有有一部分有序的，因此要拿 mid 和 left 进行比较，当 nums[mid] <= nums[left] 时，最小数字在左边， right = mid； 注意考虑特殊情况，数组没有旋转的情况，nums[mid] == nums[left] == nums[right] 的情况

4. 变态跳台阶： 用 dp[i] 存储到第 i 阶时的跳法，dp[i+1] = sum(dp)

5. 矩形覆盖： f(n) = f(n-1) + f(n-2)

6. 二进制中1的个数： 
思路一： 要将 flag 左移，因为 python 的数据类型模糊，因此要自行设置比较次数为 32
思路二： 将 n - 1，相当于二进制最后一个 1 变成 0, 这个 1 后面的所有 0 都变成 1，那么 n & (n-1) ，n 的最后一个 1 就会去掉，有多少个 1 就能进行多少次这种操作，直到 n 变为 0。要注意的是在 python 中负数可能会无限循环下去，因此 n 在变化时要 n & 0xffffffff

7. 数值的整数次方： 注意全面高效的时间复杂度为 O(logn) 的解法，将幂不断出，进行递归计算得到结果，注意可以用右移运算和位运算来提高效率。

8. 调整数组顺序使奇数位于偶数前面： 类似于冒泡排序，将奇数往前面排，外层从前往后遍历，内层从后往前遍历，当遇到前偶后奇的情况就互换。 时间复杂度 O(n^2)
或者用时间换空间，当扫描到偶数时就把它放到一个新的数组中，扫描到奇数就往前面放，最后把偶数数组填充到原数组末尾，时间 O(n)，空间 O(n)

9. 合并两个排序的链表： 二叉树的归并排序

10. 包含min函数的栈：要求在 O(1) 的时间返回栈的最小值，那么就需要用空间换时间，建立一个辅助栈 min_stack 保存当前栈中的最小值，那么栈的最小值就是 min_stack 的最后一个元素，注意删除元素的时候，要同时把 min_stack 中的最后一个元素删除。

11. 栈的压入、弹出序列： 建立一个辅助栈 stack，元素按照 pushV 的顺序压入，按照 popV 的顺序弹出，注意当 stack[-1] == popV[0] 时，说明此时需要弹出元素，stack.pop(), popV.pop(0)， 时间复杂度 O(n)，空间复杂度 O(n)

12. 二叉搜索树的后序遍历序列： 找到 root 的位置，然后将数组分为两个部分，也就是 BST 的左子树和右子树，再递归去判断。不要去用前一个数比 root 小，后一个数比 root 大去找 root 的位置，这样情况很复杂，有可能全比 root 大，也可能全比 root 小，还可能找到 root 后，前半部分包含比 root 大的，后半部分包含比 root 小的，这样判断条件太多。最好的方法是当遇到第一个比 root 更大的元素时，就将数组分为两个部分，再遍历右半部分的所有数组，如果出现比 root 更小的就返回 False。

13. 连续子数组的最大和：动态规划，用 dp[i] 存储包含第 i 个数字的子数组最大值，dp[i] = max(dp[i-1]+nums[i], nums[i])，用 max_sum 存储全局的最大值

14. 第一个只出现一次的字符位置： 遍历一次 s，用 dict 存储字符及其出现次数，遍历第二次 s，找到只出现一次的字符的位置，时间复杂度 O(n)，空间复杂度可以看做是 O(1)，因为字母的个数是有限的

15. 左旋转字符串： 直接切片，或者根据翻转字符串来解，按照 n 将 s 分成左右两部分，如 left = 'abc', right = 'XYZdef', 分别将两部分翻转 s = 'cbafedZYX', 再翻转整个 s，s = 'XYZdefabc'

16. 翻转单词顺序列： 先把整个字符串翻转了，再按照空格切分成每个单词，再将每个单词翻转。注意当字符串为 "" 和 " " 的特殊情况

17. 把字符串转换成整数： 没有 leetcode 8 那么复杂

18. 数组中重复的数字： 是否可以改变数组？如果不可以改变，则开辟一个辅助空间存储，时间 O(n)，空间 O(n)，用字典存，那么找是否有重复数字这一步的时间就是 O(1)。 如果可以改变数组，可以达到时间 O(n), 空间 O(1)。
由于数字都是在 0 到 n-1 范围内的，我们可以把数字放到对应的坐标下去，当发现某个数字的坐标已经有了一个相等的数字，就返回该数字。 

19. 字符流中第一个不重复的字符：用字典存储字符流中每个字符出现的次数，要注意在 python2 中字典的存储是无序的，因此返回第一个只出现一次的字符时，不能去遍历字典，可以去遍历 s，这样就是按照顺序排列的。

20. 链表中环的入口结点： 快慢指针先判断链表是否有环，如果有环的话，就让 slow 回到原点，fast 在相遇的点，然后两者同步走，当 fast 和 slow 再次相遇，则是环的入口节点。

21. 删除链表中重复的结点： 注意重复的节点是不保留的，分两步走，当前节点值不等于下一个节点值时，pre 和 cur 都直接往前推一个； 当前节点值等于下一个节点值时，继续判断后面的有没有相等的，直到遇到不相等的，此时 pre.next 就是下一个不相等的节点，cur 也是下一个不相等的节点。

22. 数据流中的中位数

23. 矩阵中的路径： 先找到第一个节点，再去上下左右的遍历，当路径走不通时就回溯，同时将访问过的 visited 节点改为 False

Hard 不太会：
1. 替换空格： 注意在 python 中 str 类型是不可变的，因此不能去用比如说 `s = s + '0'*cnt*2` 的方式来修改 str 的值，可以先用 list(s) 转为数组，再去扩充数组的长度，然后从后往前遍历去填充字符。

2. 树的子结构： 先找到第一个相同的节点，然后用一个函数去判断 B 是否是 A 的子结构，如果不是，再在主函数体中取找下一个相同的节点

3. 复杂链表的复制： 分为三步，首先在原链表的每个节点后面都复制一个相同的节点，然后找到每个新节点的 random 指针，最后将新节点从原链表中拆分出来，得到一个新的链表。 注意最后拆分的时候，链表的最后一个节点是 pnew， 因此循环的终止条件为 while pnew.next

4. 最小的K个数(最大堆解法)：构建一个大小为 k 的最大堆，那么堆中的最大数就是 tinput[0]，然后数组从小标为 k 的数开始遍历，如果 tinput[i] < tinput[0] ，那么这个数就可能成为最小的 k 个数之一，则两者互换，同时要调整堆使堆的最大元素位于 index=0 的位置，遍历完成后前 k 个数就是最小的 k 个数。 时间复杂度为 O(nlogk)，适用于海量数据。

5. 丑数： 注意特殊情况 index == 0 时，如何更新下标，只要找到第一个 * 2 ，* 3 ，* 5 比当前最后一个丑数更大数，记下此时的坐标，那下一次就只要在这三个数中选最小值即可。

6. 数字在排序数组中出现的次数：用两次二分查找，第一次找到最左边的 k 的坐标 start，第二次找到最右边 k 的坐标 end，那么出现的次数就是 end-start+1。 注意找最左边的 k 相当于找第一个大于等于 k 的数，因此一开始的比较是用 nums[mid] >= k，最后返回 left； 找最右边的 k 相当于找最后一个小于等于 k 的数，因此比较用 nums[mid] <= k，最后返回 right

7. 和为S的连续正数序列： 用 left 和 right 分别表示连续整数序列的左右范围，根据当前序列和与 tsum 进行比较，从而判断是否需要删除和添加数字。

8. 和为S的两个数字： 双指针，left 和 right 分别指向左右，array[left] + array[right] == tsum 时，就判断两者乘积是否更小，并记录下来； < tsum 就说明需要一个更大的数字，那么 left + 1； > tsum 就说明需要一个更小的数字，right - 1。
注意 array 为空时，和为 s 的两个数字不存在时，返回 []

9. 扑克牌顺子: 先将 numbers 排序，计数 0 的个数，然后计算其余数字有多少个需要用 0 来补足的间隙，如果 gap <= zeros ，就可以凑成顺子。 注意 numbers 为空，numbers 中有重复数字的特殊情况！！！ 

10. 孩子们的游戏(圆圈中最后剩下的数)：用数组代替环形链表，按照下标依次删除数组中的元素，直到数组中只有一个数字，要注意第 m 个人的下标是 m-1，当遍历到的下标 i >= len(nums) 时，就要返回头部，因此让 i % len(nums) 得到下一个要删除的数字的坐标。 时间复杂度为 O(mn)，空间复杂度 O(n)

11. 求1+2+3+...+n：利用逻辑运算符 and 的短路特性，一句话完成， return n and n +  self.Sum_Solution(n-1)

12. 不用加减乘除做加法： 用二进制，先不计算进位，直接相应位置的数字相加得到结果，也就是相当于两个数字异或；然后得到进位的数字再与之前的相加，循环计算直到没有进位数字为止。

13. 构建乘积数组： 先从前往后计算，再从后往前计算

14. 二叉树的下一个结点： 分情况考虑，pNode 有右子树，则返回右子树最左边的节点；pNode 没有右子树，要么是节点全部遍历完成，要么是该节点所在的左子树全部遍历完成，因此要去找该节点所在左子树的根节点

15. 机器人的运动范围： 回溯

Very hard 完全不会：
1. 二叉搜索树与双向链表：BST 中序遍历是有序的，这道题的结构和中序遍历一样，是左跟右，只是把中间的访问节点改成了指针的调整。设置两个指针 pHead 和 pEnd 分别指向转化后的双向链表的表头和表尾，首先找到表头，也就是 BST 最左边的节点，一直往左边递归遍历，self.Convert(root.left)，找到之后 pEnd 也是指向第一个元素，当遍历到下一个元素时，就修改指针的指向， pEnd.right = cur, cur.left = pEnd, pEnd = cur。 遍历完左子树后，再遍历右子树 self.Convert(root.right)

2. 整数中1出现的次数：从低位到高位依次计算，按照位数将数字分为左右两部分，根据当前位的数字是 0,1,>=2 来判断当前位为 1 的数字有多少个，以百位出现 1 为例
若百位为 0，比如 32056，则百位出现 1 的数字有 (00-31)1(00-99)，也就是 32 * 100 个
若百位为 1，比如 32156，则百位出现 1 的数字有 (00-31)1(00-99) 和 321(00-56)，也就是 32 * 100 + 56 + 1 个
若百位为 2，比如 32256，则百位出现 1 的数字有 (00-32)1(00-99)，也就有 (32+1) * 100 个

时间复杂度为 O(m)，m 为数字 n 的位数

3. 把数组排成最小的数：当 ab < ba 时，a 就排在比的前面，直接用冒泡排序对 numbers 里的数字按照这个规则进行排序，最后输出组合起来的结果，注意输出是一个字符串 return ''.join([str(i) for i in numbers])

4. 数组中的逆序对：利用归并排序的原理。先将数组 data 划分为长度为 1 的子数组，再按从小到大的顺序两两合并，同时计算逆序对的个数。例如 left = [3,6,8] 和 right = [4,5,7]，当 left[i] > right[j] 时，说明存在逆序对，且第 i 个数之后的所有数都会比 right[j] 更大，此时有 len(left)-i 个逆序对，然后判断 left[i] 与 right[j+1] 的大小； 当 left[i] <= right[j] 时，不存在逆序对，然后判断 left[i+1] 与 right[j] 的大小。 每次比较把较小的数字加到一个数组中，最后再把 left 或 right 剩下的数字加进去。

时间复杂度为 O(nlogn)，空间复杂度为 O(n)

5. 正则表达式匹配： 根据 pattern 的第二个字符 pattern[i] 是否为 * 来分情况判断，同时要注意几种特殊情况。
`pattern[i] != '*'` : 判断第一个字符是否符合条件，s[0] == pattern[0] or pattern[0] == '.' 返回 True
`pattern[i] == '*'` : 果第一个字符匹配成功，则判断第二个字符是否能够匹配，有三种情况，因为 x* 可以忽略，也可以匹配一次 x，也可以匹配多次 x， return self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern)  

6. 表示数值的字符串：逐个字符判断，找出所有不符合条件的返回 Fasle，情况比较多，分为 s[i] 是否为正负号、小数点、e、数字分别去判断

7. 序列化二叉树：序列化二叉树是把二叉树结构按照某个顺序遍历得到的结果保存为一个字符串，节点不存在就用 # 填充，反序列化二叉树是将字符串转为二叉树结构的过程。 我们可以用前序遍历来序列化二叉树。

8. 滑动窗口的最大值： 要想在 O(n) 时间里解决该问题，需要添加一个辅助空间，用 tmp 存储当前窗口的最大值对应的坐标（存坐标是为了方便判断当前最大值是否已经滑出窗口），以及之后可能成为后面窗口最大值的次小值，当前窗口的最大值就是 num[tmp[0]]，当前遍历到的数字比 tmp 中的数字更大时，就删除更小的数字，因为小数字不可能成为后面窗口的最大值。 注意当最大值滑出窗口后，要删掉 tmp[0]，每次遍历开始都要先判断这个。


Medium 有思路，还需要再加深一遍：
1. 从尾到头打印链表， 另一种解法
2. 用两个栈实现队列， OK
3. 旋转数组的最小数字， 再做，有一点问题
4. 变态跳台阶， OK
5. 矩形覆盖， OK
6. 二进制中1的个数， 思考更优的思路
7. 数值的整数次方， 思考时间 O(logn) 的解法
8. 调整数组顺序使奇数位于偶数前面， 没写出来，重做！考虑时间 O(n^2) 和 O(n) 的解法，同时注意扩展到不要求相对顺序不变的情况。
9. 合并两个排序的链表， OK
10. 包含min函数的栈， OK
11. 栈的压入、弹出序列， 差不多，条件判断有一点小问题，要注意
12. 二叉搜索树的后序遍历序列， 思路不对
13. 连续子数组的最大和， OK
14. 第一个只出现一次的字符位置，OK
15. 左旋转字符串， 不用切片，如何通过翻转字符串来解
16. 翻转单词顺序列， 注意特殊情况
17. 把字符串转换成整数， OK
18. 数组中重复的数字， 思考不需要辅助空间的解法
19. 字符流中第一个不重复的字符， 再做一遍
20. 链表中环的入口结点， OK
21. 删除链表中重复的结点， 还是没有完全理解
22. 数据流中的中位数， OK
23. 矩阵中的路径， 忘记返回结果，再做

Hard 不太会：
1. 替换空格， OK，但 python 中有一点需要注意
2. 树的子结构， 没完全弄懂，有一些问题
3. 复杂链表的复制， 差不多，最后拆分的时候有一点小问题
4. 最小的K个数(最大堆解法)， 思路有，但还不是特别熟练，调整堆的算法基本可以写出
5. 丑数， 更新下标的方法，特殊用例
6. 数字在排序数组中出现的次数， 有思路，写不出！
7. 和为S的连续正数序列，OK，思路没问题，但是有点小错误，难一次 AC
8. 和为S的两个数字， OK，但是要注意特殊情况，且别忘记不存在的情况
9. 扑克牌顺子， OK，考虑特殊情况！！！
10. 孩子们的游戏(圆圈中最后剩下的数)，必须能写出暴力解法，数学方法能够理解
11. 求1+2+3+...+n， OK
12. 不用加减乘除做加法， 还没完全搞懂 python 的运算
13. 构建乘积数组， OK
14. 二叉树的下一个结点， 没有右子树的情况没搞懂
15. 机器人的运动范围， 差不多，但是造成了递归栈溢出

Very hard 完全不会：
1. 二叉搜索树与双向链表，思路混乱，还写不出来
2. 整数中1出现的次数， OK
3. 把数组排成最小的数， OK
4. 数组中的逆序对， 没思路，写不出
5. 正则表达式匹配， 思路混乱，写不出
6. 表示数值的字符串， 差不多，有一些细节需要注意，小数点不能出现在 e 的后面
7. 序列化二叉树，没掌握概念，写不出
8. 滑动窗口的最大值， 思路不是很清楚


重做:
Medium
1. 从尾到头打印链表， 另一种解法
2. 旋转数组的最小数字， 再做，有一点问题
3. 二进制中1的个数， 思考更优的思路
4. 数值的整数次方， 思考时间 O(logn) 的解法
5. 调整数组顺序使奇数位于偶数前面， 没写出来，重做！考虑时间 O(n^2) 和 O(n) 的解法，同时注意扩展到不要求相对顺序不变的情况。
6. 栈的压入、弹出序列， 差不多，条件判断有一点小问题，要注意
7. 二叉搜索树的后序遍历序列， 思路不对
8. 左旋转字符串， 不用切片，如何通过翻转字符串来解
9. 翻转单词顺序列， 注意特殊情况
10. 数组中重复的数字， 思考不需要辅助空间的解法
11. 字符流中第一个不重复的字符， 再做一遍
12. 删除链表中重复的结点， 还是没有完全理解
13. 矩阵中的路径， 忘记返回结果，再做

Hard 不太会：
1. 树的子结构， 没完全弄懂，有一些问题
2. 复杂链表的复制， 差不多，最后拆分的时候有一点小问题
3. 最小的K个数(最大堆解法)， 思路有，但还不是特别熟练，调整堆的算法基本可以写出
4. 丑数， 更新下标的方法，特殊用例
5. 数字在排序数组中出现的次数， 有思路，写不出！
6. 孩子们的游戏(圆圈中最后剩下的数)，必须能写出暴力解法，数学方法能够理解
7. 不用加减乘除做加法， 还没完全搞懂 python 的运算
8. 二叉树的下一个结点， 没有右子树的情况没考虑清楚
9. 机器人的运动范围， 差不多，但是造成了递归栈溢出

Very hard 完全不会：
1. 二叉搜索树与双向链表，思路混乱，还写不出来
2. 数组中的逆序对， 没思路，写不出
3. 正则表达式匹配， 思路混乱，写不出
4. 表示数值的字符串， 差不多，有一些细节需要注意，小数点不能出现在 e 的后面
5. 序列化二叉树，没掌握概念，写不出
6. 滑动窗口的最大值， 思路不是很清楚