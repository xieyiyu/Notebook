# 搜索

<!-- GFM-TOC -->
* [BFS](#BFS)
* [DFS](#DFS)
* [Backtracking](#Backtracking)
<!-- GFM-TOC -->

## BFS
<div align="center"><img src="../../pics/leetcode/BFS.jpg"></div>

BFS 广度优先搜索的搜索过程是一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。  
  
第一层：  
0 -> {6,2,1,5};  
  
第二层：  
6 -> {4}  
2 -> {}  
1 -> {}  
5 -> {3}  
  
第三层：  
4 -> {}  
3 -> {}  
  
上述过程可知：是反复从新节点出发进行遍历操作。  
  
每一轮遍历的节点都与根节点路径长度相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的路径长度，可以推导出结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub><=d<sub>j</sub>。  
利用上述结论，可以求解最短路径  **最优解**  问题：第一次遍历到目的节点，其所经过的路径为最短路径，如果继续遍历，之后再遍历到目的节点，所经过的路径就不是最短路径。  
  
在程序实现 BFS 时需要考虑以下问题：
- 队列：用来存储每一轮遍历的节点。
- 标记：对于已经遍历的节点，需要标记，避免重复遍历。

## DFS
<div align="center"><img src="../../pics/leetcode/DFS.jpg"></div>

深度优先搜索在得到一个新节点时立马对新节点进行遍历：  
从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；  
如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。  
  
从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解 **可达性** 问题。  
  
在程序实现 DFS 时需要考虑以下问题：  
- 栈：用来存储当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以使用递归栈。
- 标记：对已经遍历过的节点进行标记。

## Backtracking
回溯法属于 DFS ，主要用于求解 **排列组合** 问题。  
在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。  
因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：
- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

### Letter Combinations of a Phone Number
[Leetcode : 17. Letter Combinations of a Phone Number(Medium)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.  
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.  
>  
>Input: "23"  
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

思路：运用 DFS

```python
def letterCombinations(self, digits):
    if not digits:
        return []
    
    dict = {'2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']}
    
    def dfs(d, string):
        if not d:
            res.append(string)
            return
        
        num = d[0]
        rest_num = d[1:]
        for char in dict[num]:
            dfs(rest_num, string+char)
            
    res = []
    dfs(digits, '')
    return res
```

### Generate Parentheses
[Leetcode : 22. Generate Parentheses(Medium)](https://leetcode.com/problems/generate-parentheses/description/)

```
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

思路：括号的长度是 2n，在 [1, 2n] 之间，左括号的数量必定是小于等于右括号的数量，但右括号的数量小于左括号的数量时，则终止递归。  
因此用 DFS， left 代表左括号的数量，right 代表右括号的数量，如果左括号有剩余，就在结果上 + '('。

```python
def generateParenthesis(self, n):
    if n == 0:
        return []
    
    def dfs(left, right, string):
        if right < left:
            return 
        if left == 0 and right == 0:
            res.append(string)
        if left > 0:
            dfs(left-1, right, string + '(')
        if right > 0:
            dfs(left, right-1, string + ')')
        
    
    res = []
    dfs(n, n, '')
    return res
```

