# 搜索

<!-- GFM-TOC -->
* [BFS](#BFS)
* [DFS](#DFS)
* [Backtracking](#Backtracking)
	* [Letter Combinations of a Phone Number](#letter-combinations-of-a-phone-number)
	* [Generate Parentheses](#generate-parentheses)
	* [Combination Sum](#combination-sum)
	* [Permutations](#permutations)
	* [Subsets](#Subsets)
	* [Word Search](#word-search)
	* [N-Queens](#n-queens)
<!-- GFM-TOC -->

## BFS
<div align="center"><img src="../../pics/leetcode/BFS.jpg"></div>

BFS 广度优先搜索的搜索过程是一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。  
  
第一层：  
0 -> {6,2,1,5};  
  
第二层：  
6 -> {4}  
2 -> {}  
1 -> {}  
5 -> {3}  
  
第三层：  
4 -> {}  
3 -> {}  
  
上述过程可知：是反复从新节点出发进行遍历操作。  
  
每一轮遍历的节点都与根节点路径长度相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的路径长度，可以推导出结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub><=d<sub>j</sub>。  
利用上述结论，可以求解最短路径  **最优解**  问题：第一次遍历到目的节点，其所经过的路径为最短路径，如果继续遍历，之后再遍历到目的节点，所经过的路径就不是最短路径。  
  
在程序实现 BFS 时需要考虑以下问题：
- 队列：用来存储每一轮遍历的节点。
- 标记：对于已经遍历的节点，需要标记，避免重复遍历。

## DFS
<div align="center"><img src="../../pics/leetcode/DFS.jpg"></div>

深度优先搜索在得到一个新节点时立马对新节点进行遍历：  
从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；  
如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。  
  
从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解 **可达性** 问题。  
  
在程序实现 DFS 时需要考虑以下问题：  
- 栈：用来存储当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以使用递归栈。
- 标记：对已经遍历过的节点进行标记。

## Backtracking
回溯法属于 DFS ，主要用于求解 **排列组合** 问题。  
在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。  
因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：
- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

### Letter Combinations of a Phone Number
[Leetcode : 17. Letter Combinations of a Phone Number(Medium)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.  
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.  
>  
>Input: "23"  
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

思路：运用 DFS

```python
def letterCombinations(self, digits):
    if not digits:
        return []
    
    dict = {'2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']}
    
    def dfs(d, string):
        if not d:
            res.append(string)
            return
        
        num = d[0]
        rest_num = d[1:]
        for char in dict[num]:
            dfs(rest_num, string+char)
            
    res = []
    dfs(digits, '')
    return res
```

### Generate Parentheses
[Leetcode : 22. Generate Parentheses(Medium)](https://leetcode.com/problems/generate-parentheses/description/)

```
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

思路：括号的长度是 2n，在 [1, 2n] 之间，左括号的数量必定是小于等于右括号的数量，但右括号的数量小于左括号的数量时，则终止递归。  
因此用 DFS， left 代表左括号的数量，right 代表右括号的数量，如果左括号有剩余，就在结果上 + '('。

```python
def generateParenthesis(self, n):
    if n == 0:
        return []
    
    def dfs(left, right, string):
        if right < left:
            return 
        if left == 0 and right == 0:
            res.append(string)
        if left > 0:
            dfs(left-1, right, string + '(')
        if right > 0:
            dfs(left, right-1, string + ')')
        
    
    res = []
    dfs(n, n, '')
    return res
```

### Combination Sum
[Leetcode : 39. Combination Sum(Medium)](https://leetcode.com/problems/combination-sum/description/)

>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.  
The same repeated number may be chosen from candidates unlimited number of times.  

```
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```

思路：用 DFS，要注意的是每次循环遍历需要从当前位置之后开始遍历，否则会出现重复计算。  
且 arr 不能用 arr.append, 会造成两种问题：
- 若在 dfs 的参数中用 arr.append, 相当于是 arr = arr.append, 执行后发现 arr 的类型变为了 NoneType。 因为 append 会修改 arr 本身，并且返回 None，不能把返回值再赋值给 a。
- 若在调用 dfs 之前，单独用 arr.append(cans[i])，会一直往 arr 里面加元素。
因此需要用 arr+[cans[i]] 来追加元素。

```python
def combinationSum(self, candidates, target):
    res = []
    def dfs(cans, tar, start, arr):
        if tar < 0:
            return 
        if tar == 0:
            res.append(arr)
            return 
        for i in range(start, len(cans)):
            if cans[i] <= tar:
                dfs(cans, tar-cans[i], i, arr+[cans[i]])
    
    dfs(candidates, target, 0, [])
    return res
```

### Combination Sum II
[Leetcode : 40. Combination Sum II(Medium)](https://leetcode.com/problems/combination-sum-ii/description/)

>Each number in candidates may only be used once in the combination.

思路：由于一个数字用多次，因此递归时要从 cans[i+1:] 开始

```python
def combinationSum2(self, candidates, target):
    res = []
    def dfs(cans, tar, start, arr):
        if tar < 0:
            return 
        if tar == 0 and arr not in res:
            res.append(arr)
            return 
        for i in range(len(cans)):
            if cans[i] <= tar:
                dfs(cans[i+1:], tar-cans[i], i+1, arr+[cans[i]])
    candidates = sorted(candidates)
    dfs(candidates, target, 0, [])
    return res
```

### Combination Sum III
[Leetcode : 216. Combination Sum III(Medium)](https://leetcode.com/problems/combination-sum-iii/description/)

>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.  
Input: k = 3, n = 7  
Output: [[1,2,4]]

```python
def combinationSum3(self, k, n):
    res = []
    nums = [i for i in range(1, 10)]
    
    def dfs(nums, target, arr):
        if target < 0:
            return 
        if target == 0 and len(arr) == k and sorted(nums) not in res:
            res.append(arr)
            return
        for i in range(len(nums)):
            dfs(nums[i+1:], target-nums[i], arr + [nums[i]])
    
    dfs(nums, n, [])
    return res
```

### Permutations
[Leetcode : 46. Permutations(Medium)](https://leetcode.com/problems/permutations/description/)

>Given a collection of distinct integers, return all possible permutations.  
数组元素不重复，排列组合

```python
def permute(self, nums):
    res = []
    def dfs(n, arr):
        if not n:
            res.append(arr)
            return 
        for i in range(len(n)):
            dfs(n[:i]+n[i+1:], arr+[n[i]])
        
    dfs(nums, [])
    return res            
```
备注：不要用 pop()，会改变原数组，导致最后数组为空，直接 n[:i]+n[i+1:] 表示删除第 i 个数

### Permutations II
[Leetcode : 47. Permutations II(Medium)](https://leetcode.com/problems/permutations-ii/description/)

>Given a collection of numbers that might contain duplicates, return all possible unique permutations.  
数组元素重复，排列组合

直接在上一题的基础上添加条件 if not n and arr not in res，会超时。  
为了提交效率，可以先对 nums 排序，那么相同的元素会在一起，在遍历时，如果遇到相同的元素，其结果会和之前的元素相同，就不要重复递归了。由于添加了元素是否重复的判断，那么得到的 arr 便也不会重复了，因此 if not n 后面不用再接着判断 arr 是否存在于 res 中。

```python
def permuteUnique(self, nums):=
    res = []
    def dfs(n, arr):
        if not n:
            res.append(arr)
            return 
        for i in range(len(n)):
            if i > 0 and n[i] == n[i-1]:
                continue
            dfs(n[:i]+n[i+1:], arr+[n[i]])
            
    nums.sort()
    dfs(nums, [])
    return res 
```

### Combinations
[Leetcode : 77. Combinations(Medium)](https://leetcode.com/problems/combinations/description/)

```
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```python
def combine(self, n, k):
    res = []
    nums = [i for i in range(1, n+1)]
    def dfs(nums, k, arr):
        if len(arr) == k and sorted(arr) not in res:
            res.append(arr)
            return 
        for i in range(len(nums)):
            dfs(nums[i+1:], k, arr+[nums[i]])
            
    dfs(nums, k, [])
    return res
```

### Subsets
[Leetcode : 78. Subsets(Medium)](https://leetcode.com/problems/subsets/description/)

```
Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```python
def subsets(self, nums):
    res = []
    def dfs(nums, arr):
        res.append(arr)
        for i in range(len(nums)):
            dfs(nums[i+1:], arr+[nums[i]])
    
    dfs(sorted(nums), [])
    return res
```

### Subsets II
[Leetcode : 90. Subsets II(Medium)](https://leetcode.com/problems/subsets-ii/description/)

nums 变为包含重复数字，其余与上题一样。  
只需要在 res.append(arr) 之前添加判断条件 if arr not in res 即可。

### Word Search
[Leetcode : 79. Word Search(Medium)](https://leetcode.com/problems/word-search/description/)

```
Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those 
horizontally or vertically neighboring. The same letter cell may not be used more than once.
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

```python

```







### N-Queens
[Leetcode : 51. N-Queens(Hard)](https://leetcode.com/problems/n-queens/description/)

>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other  
Given an integer n, return all distinct solutions to the n-queens puzzle.  
Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.  

<div align="center"><img src="../../pics/leetcode/n-queens.jpg"></div>

```python

```

### N-Queens II
[Leetcode : 52. N-Queens II(Hard)](https://leetcode.com/problems/n-queens-ii/description/)

>Given an integer n, return the number of distinct solutions to the n-queens puzzle.

```python
```