# 排序
排序可以分为比较排序和非比较排序。比较排序有插入排序、希尔排序、选择排序、冒泡排序、快速排序、堆排序和归并排序；非比较排序有桶排序、基数排序和计数排序。  
稳定排序：在排序前有x<sub>i</sub>=x<sub>j</sub>，且x<sub>i</sub>排在x<sub>j</sub>前面，在排序后仍然是x<sub>i</sub>排在x<sub>j</sub>前面，则这种排序算法是稳定的。

<!-- GFM-TOC -->
* [冒泡排序](#冒泡排序)
* [快速排序](#快速排序)
* [堆排序](#堆排序)
* [桶排序](#桶排序)
<!-- GFM-TOC -->

## 冒泡排序
将第一个记录arr[0]与第二个记录arr[1]比较，若arr[0]>arr[1]，以此类推到最后一个记录，一次冒泡的结果将数组中最大的数排到arr末尾。
外层for控制排序的执行次数，内层for控制一次排序中相邻记录的比较和交换，一共要执行n次冒泡，每次冒泡比较次数为n-i，因此时间复杂度O(n<sup>2</sup>)。相邻元素相等时没有发生交换，因此冒泡排序是稳定的。

```python
def bubble_sort(arr):
    length = len(arr)
    for i in range(length):
        for j in range(length-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]  #1
    return arr
```
备注：
1. python交换两个元素不需要中间变量  a,b = b,a
2. 算法改进：
优化1：若某一次遍历没有发生数据交换，则数组已经排好序，无需继续冒泡，设置一个flag来标明没有发生交换的时候
```python
def bubble_sort1(arr):
    length = len(arr)
    for i in range(length):
        flag = 1 ###
        for j in range(length-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag = 0 ###
        if flag:
            break # 已排好序，直接跳出
    return arr
```

优化2：记录每次遍历最后发生交换的位置，则该位置后面已经排好序，则下次冒泡只需遍历该位置之前的数组
```python
def bubble_sort2(arr):
    length = len(arr)
    k = length-1 # j的循环范围
    for i in range(length):
        flag = 1
        for j in range(k):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                k = j # 记录最后一次交换的位置
                flag = 0
        if flag:
            break # 已排好序，直接跳出
    return arr
```

## 快速排序
快速排序采用分治思想，以第一个数arr[0]作为基准，通过一趟排序将数据分成两部分，比arr[0]小的数排在左边，比arr[0]大的数排在右边，再对这两个部分进行快排，所有序列长度为1时则序列已排好序。  
快速排序的时间复杂度为o(nlogn)，空间复杂度o(n)  
大小相同的元素可能会交换顺序，因此快速排序是不稳定排序

```python
def quick_sort(arr, left, right):
    if left >=  right:
        return 
    low = left
    high = right
    key = arr[left]
    while left < right: 
        while left < right and arr[right] >= key:  #1
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] <= key:
            left += 1
        arr[right] = arr[left]
    arr[left] = key
    quick_sort(arr, low, left-1)
    quick_sort(arr, left + 1, high)
```

备注：1. 必须要再加一层while left < right，否则没有终止条件，会出现数组越界

## 堆排序

## 桶排序

## 总结
