# 排序
<!-- GFM-TOC -->
* [冒泡排序](#冒泡排序)
* [快速排序](#快速排序)
* [堆排序](#堆排序)
* [桶排序](#桶排序)
<!-- GFM-TOC -->

## 冒泡排序
将第一个记录arr[0]与第二个记录arr[1]比较，若arr[0]>arr[1]，以此类推到最后一个记录，一次冒泡的结果将数组中最大的数排到arr末尾。
外层for控制排序的执行次数，内层for控制一次排序中相邻记录的比较和交换，时间复杂度O(n<sup>2</sup>),

```python
def bubble_sort(arr):
    length = len(arr)
    for i in range(length):
        for j in range(len(arr)-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]  #1
    return arr
```
备注：
1. python交换两个元素不需要中间变量  a,b = b,a
2. 算法改进：
优化1：若某一次遍历没有发生数据交换，则数组已经排好序，无需继续冒泡，设置一个flag来标明没有发生交换的时候
```python
def bubble_sort1(arr):
    length = len(arr)
    for i in range(length):
        flag = 1 ###
        for j in range(len(arr)-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                flag = 0 ###
        if flag:
            break # 已排好序，直接跳出
    return arr
```

优化2：记录每次遍历最后发生交换的位置，则该位置后面已经排好序，则下次冒泡只需遍历该位置之前的数组
```python
def bubble_sort2(arr):
    length = len(arr)
    k = length-1 # j的循环范围
    for i in range(length):
        flag = 1
        for j in range(k):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                k = j # 记录最后一次交换的位置
                flag = 0
        if flag:
            break # 已排好序，直接跳出
    return arr
```

## 快速排序
以第一个数arr[0]作为基准，通过一趟排序将数据分成两部分，比arr[0]小的数在前面，比arr[1]大的数排在后面，再对这两个部分进行快排，所有序列长度为1时则序列易排好序。

```python
def quick_sort(arr, left, right):
    if left >=  right:
        return 
    low = left
    high = right
    key = arr[left]
    while left < right: 
        while left < right and arr[right] >= key:  #1
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] <= key:
            left += 1
        arr[right] = arr[left]
    arr[left] = key
    quick_sort(arr, low, left-1)
    quick_sort(arr, left + 1, high)
```

备注：1. 必须要再加一层while left < right，否则没有终止条件，会出现数组越界

## 堆排序

## 桶排序