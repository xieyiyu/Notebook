# 测试
<!-- GFM-TOC -->
* [测试基础](#测试基础)
	* [测试方法](#测试方法)
		* [黑盒测试](#黑盒测试)
		* [白盒测试](#白盒测试)
		* [灰盒测试](#灰盒测试)
		* [灰度测试](#灰度测试)
		* [单元测试](#单元测试)
		* [集成测试](#集成测试)
		* [系统测试](#系统测试)
		* [验收测试](#验收测试)
		* [回归测试](#回归测试)
	* [测试流程](#测试流程)
* [测试用例](#测试用例)
	* [测试用例组成](#测试用例组成)
	* [测试用例设计方法](#测试用例设计方法)
* [测试报告](#测试报告)
* [bug](#bug)
	* [bug 的生命周期](#bug-的生命周期)
	* [bug 严重级别划分](#bug-严重级别划分)
* [接口测试](#接口测试)
* [性能测试](#性能测试)
* [兼容性测试](#兼容性测试)
* [自动化测试](#自动化测试)
* [TDD](#tdd)
* [软件相关](#软件相关)
	* [软件生命周期](#软件生命周期)
	* [瀑布模型](#瀑布模型)
	* [V 模型](#v-模型)
	* [螺旋模型](#螺旋模型)
	* [敏捷开发](#敏捷开发)
	* [软件质量](#软件质量)
* [问答题](#问答题)
* [职业规划](#直接规划)
<!-- GFM-TOC -->

## 测试基础
### 测试方法
按测试对象：黑盒、白盒、灰盒  
按测试手段：手工、自动化  
按整体-局部(开发阶段): 单元、集成、系统、验收  
按程序是否运行：静态测试，即文档测试（不执行代码），如文档评审、代码走查；动态测试，如黑白灰盒

#### 黑盒测试：
也称功能测试或数据驱动测试，它是通过测试来检测每个功能是否都能正常使用，不考虑程序内部结构和内部特性的情况。

方法： 等价类划分法、边界值分析法、错误推断法、因果图法、判定表法

#### 白盒测试： 
白盒测试又称结构测试、逻辑驱动测试或基于代码的测试，需要全面了解程序内部逻辑结构、对所有逻辑路径进行测试。

- 静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。

- 动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。

**白盒的方法，下面覆盖程度由弱到强**  
1. 语句覆盖： 最基本的结构覆盖要求，设计出来的测试用例要保证程序中的每一个语句至少被执行一次。  
缺点： 无法测试隐藏条件，比如 if 结构没有写 else 的执行分支，就不会测试

2. 判定覆盖： 也叫分支覆盖，要求选择足够的测试用例，使得程序中每个判定至少有一次为真值，有一次为假值，即：程序中的**每个分支**至少执行一次。

3. 条件覆盖： 要求所设计的测试用例能使每个判定中的每一个条件都获得可能的取值，即**每个条件**至少有一次真值、有一次假值。

4. 判定/条件覆盖：设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。

5. 组合覆盖： 每个判定中条件结果的所有可能组合至少出现一次。

6. 路径覆盖： 覆盖程序中所有可能的路径，最强的覆盖准则。

#### 灰盒测试
灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。灰盒测试不像白盒那样详细、完整，但又比黑盒测试更关注程序的内部逻辑，常常是通过一些表征性的现象、事件、标志来判断内部的运行状态。

#### 灰度测试
在某项产品或应用正式发布前，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题。

AB test 就是一种灰度发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。

#### 单元测试
单元测试是对软件中的最小可测试单元（模块）进行检查和验证，由开发人员完成，属于白盒测试方法。  
单元测试用于验证编码单元的正确性，单元测试的测试用例根据详细设计的结果来设计。单元测试使用到单元的规格说明和单元的源代码，单元测试也叫模块测试。

单元测试的策略： 逻辑覆盖、 循环覆盖、 同行评审、 桌前检查、 代码走查、 代码评审、 数据流分析

python 中可以用 unittest 模块进行单元测试。 在Web开发过程中，单元测试实际上就是一些“断言”（assert）代码。 

断言是判断一个函数或对象的一个方法所产生的结果是否符合期望结果。

[单元测试方法以及实例](https://www.cnblogs.com/wf-skylark/p/9306831.html)

#### 集成测试
集成测试也叫组装测试或联合测试。在单元测试的基础上，将所有模块依据系统概要设计组装成为子系统或系统，进行集成测试。用于验证详细设计。需要采用增量集成的方法，注重接口测试。

测试方法： 白盒测试、黑盒测试

##### 测试桩
测试桩： 一般在自顶向下的集成时使用，在集成测试前要为被测模块编制一些模拟其下级模块功能的“替身”模块，以代替被测模块的接口来接收或是传递被测模块的数据，这些专供测试用的“假”模块称为被测模块的桩模块，也就是“测试桩”。

目的： 工作的项目会调很多第三方的接口，为了模拟异常场景测试和不产生第三方接口费用，所以用测试桩。

##### 驱动测试
驱动测试： 一般在自底向上的集成时使用，也就是需要测试的模块是中间模块，没有 main() 函数，那就可以写一个模块来代替主模块，包含 main 函数，然后再调用中间模块，让它可以运行起来。

比如有 A、B、C、D 四个模块待开发，A 是主入口，包含 main 函数，B 是中间模块，A 调用 B，B 调用 C、D，那么如果 B 先完成开发，需要做单元测试：
1. 可以写两个模块 sc 和 sd 来代替 C 和 D，这就是测试桩； 
2. 写一个模块来代替 A，提供 main 方法去调用 B 模块，这就是驱动测试。

#### 系统测试
基于系统整体需求说明书的黑盒类测试，是对整个产品进行测试，目的是验证系统是否满足了需求规格的定义，找出与需求规格不相符合或与之矛盾的地方。用于验证概要设计，一般采用黑盒测试方法。

既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交个用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。

#### 验收测试
验收测试是是部署软件之前的最后一个测试操作，确保所开发的软件产品符合用户的各项要求。 用于验证正确实现了需求。

测试方法： 黑盒测试、α测试、β测试

注意验证的都是对应的，但是依据是前一个:  
需求分析 -> 概要设计 -> 详细设计 -> 编码
验收测试 <- 系统测试 <- 集成测试 <- 单元测试       

##### α测试、β测试
α测试： 由一个用户在开发环境下进行的测试，可以是公司内部的用户在模拟实际操作环境下进行的测试。
注意α测试不能由程序员或测试员完成。
  
β测试： 用户在不同场所进行测试。

α测试和β测试都属于验收测试，α测试先于β测试执行

#### 回归测试
在发生修改之后重新测试先前的测试用例以保证修改的正确性。   

#### 测试中哪一步最重要？
测试是一个完整的流程，每一部分都是必不可少的，然后再列举每一部分的作用。

### 测试流程
1. 明确测试需求和方案
2. 测试用例编写
3. 执行测试，对测试用例进行补充和完善
4. 得到测试结果和报告
5. 文档归档
6. 发布

正式测试前先向主管确认项目排期。 接收版本 App测试版本送测规范 UI测试：核对rp/效果图 功能测试：核对需求文档、兼容性测试、性能压力测试， 尽快申请到正式环境下测试，后台订单统计测试、用户行为统计测试、发送上线报告、回归测试 

## 测试用例
### 测试用例组成
excel： 级别、执行方式（手动、自动）、主模块、子模块、测试步骤、预期结果

测试结果： 模块、具体测试点、测试人、测试结果、备注

测试用例组成元素
用例ID、 用例名称、测试目的、测试级别、参考信息、测试环境、前提条件、测试步骤、预期结果、设计人员

### 测试用例设计方法
**测试理论角度分析**  
1. 等价类划分法
将测试范围划分为几个互不相交的子集，其并集是全集，从每个子集中选出若干个**有代表性**的值作为测试用例，
有效等价类和无效等价类两种

划分到什么程度合适？看有多少资源和时间，以及是否值得

2. 边界值分析法
选出的测试用例，应选取正好等于、刚刚大于、刚刚小于边界的值。

3. 错误推测法
依靠经验和直觉，从而有针对性的编写检查这些错误的测试用例

4. 判定表法
是功能测试中最严谨的测试方法，适合逻辑判断复杂的场景，通过穷举条件或得结果，对结果再进行合并优化，得到一个判断清晰的策略表。 判定表由因果图生成。

5. 正交实验法
在各因素相互独立的情况下，设计出正交表（按一定规则生成的表，均匀分布），找出能以少数代替全面的测试用例。

**从用户角度设计**  
1. 功能测试用例
按照主要功能、次要功能顺序写；按照产品使用顺序写

2. 性能测试用例
查看功能测试用例，思考哪些在操作时会需要考虑性能

3. 压力测试用例
增加次数或延迟时间

4. 兼容性测试
在不同平台上使用，容错能力

5. 区分用例的重要性

## 测试报告
测试目的、背景
测试概要： 测试方法、范围、测试环境、测试工具
测试点，测试执行情况，测试结果、测试人
缺陷分析、遗留 bug
测试结论与建议

## bug
### bug 的生命周期
测试人员应追踪 bug 的整个生命周期，从新建(new) 到关闭(closed)

- new: 新建 bug，未经评审需决定是否指派给开发人员进行修改
- open: 确认是需要修改的 bug，指派给开发人员
- fixed: 开发人员修改后，需回归测试验证
- delay: 暂时不需要修改的 bug
- closed: 经过测试人员回归验证后，关闭 bug
- reopen: 经验证后发现未修改完成，则重新打开，重新修改

### bug 严重级别划分
- 致命： 主程序不通，系统无法运行等。如内存泄露、严重数值计算错误、易崩溃、功能与需求设计不符等
- 严重： 影响系统功能或操作、主要功能严重缺陷，但不影响系统稳定性。如功能未实现、功能报错、轻微计算失误
- 一般： 界面、性能缺陷。如边界条件下错误、大数据无响应等
- 建议： 易用性及建议性问题

## 接口测试
https://www.cnblogs.com/feng0815/p/7509541.html
### 接口
- 程序内部接口： 方法与方法之间、模块与模块之间的交互，供内部系统进行调用
- 系统对外接口： 需要从别的网站或服务器获取资源信息，通过他们的 api

**常见接口**  
- webService 接口：走 SOAP 协议通过 HTTP 传输，请求报文和返回报文都是 XML 格式，可以用 SoapUI、jmeter、loadrunner 等工具测试
- HTTP API 接口： 走 HTTP 协议，通过路径区分调用方式，请求报文为 key-value 形式，返回报文为 json 串； 有 post 和 get 等方法，可以用 postman、RESTClient、jmeter、loadrunner 等工具测试

接口测试是测试系统组件间接口，主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。实际上是黑盒测试。

重点: 检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。

接口测试没有页面，通过接口规范文档上的调用地址、请求参数、拼接报文，然后发送请求，检查返回结果，只需测入参和出参。

### 接口组成
接口文档组成： 接口说明、调用 url、 请求方法、 请求参数（参数类型、说明）、返回参数说明

接口： 请求地址、请求方法、请求参数（入参、出参）、部分接口有请求头 header（存放校验信息，是否有权限请求服务器，如cookie）

#### 为什么要做接口测试
- 可以发现很多在页面上操作无法发现的 bug， 比如登陆的后端校验，防止使用抓包直接绕过前端校验，防止 SQL 注入
- 检查系统的异常处理能力
- 检查系统的安全性、稳定性

### 接口测试的方法
1. 接口请求报文拼接：传参方式  
用 key-value 或输入 json 串
2. post 和 get 请求  
get 请求直接在浏览器输入，浏览器能够直接请求到的都是 get 请求； post 需要借助工具发送

通用接口用例设计：
1. 通过性验证：按照接口文档的参数等正常传入，看是否能返回正确结果
2. 参数组合：
3. 接口安全： 绕过验证、绕过身份授权、参数是否加密、密码安全规则等
4. 异常验证： 传非必传、参数类型、入参长度

### 接口测试流程
1. 需求评审，熟悉业务和需求
2. 测试接口文档，由开发提供接口文档
3. 根据文档写测试用例
4. 用例评审
5. 执行测试，查看接口返回的数据是否正确，是否与文档、数据库一致
6. 提交测试报告

## 性能测试
性能测试： 通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。
 
### 关键监控指标
资源指标： cpu 利用率、 内存利用率、 磁盘 IO、 网络带宽
系统指标： 并发用户数、 在线用户数、 平均响应时间、 事务成功率、 错误率

### 性能测试的类型
1. 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考
2. 负载测试：是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。
3. 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。
4. 稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。
5. 并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题

### 压力测试与负载测试区别
负载测试是通过改变系统负载方式、增加负载等来发现系统中所存在的性能问题。可以发现系统可能存在的性能瓶颈、内存泄漏、不能实时同步等问题。（比如增加用户访问数量）

压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。可以把压力测试看做负载测试的一种。主要关注系统的稳定性。（比如程序长时间运行，有稳定性测试和破坏性测试）

简单理解： 负载测试就是不断增加压力，进行测试。 压力测试就是最大负载下的测试。

### app 性能测试指标
1. 内存： 应用在空闲状态、中等规格、满规格下的内存消耗情况，应用内存峰值、应用内存泄露、应用是否常驻内存、压力测试后的内存使用。
2. CPU
3. 流量： 应用首次启动流量提示、应用后台连续运行2小时的流量值、应用高负荷运行的流量峰值。
4. 电量： 安装后、正常使用、长时间连续使用
5. 启动速度： 首次启动、非首次启动、应用界面切换
6. 滑动速度、界面切换速度
7. 与服务器交互的网络速度

## 兼容性测试
兼容性测试 CTS ： 指对所设计程序与硬件、软件之间的兼容性的测试。  
常见的有： 浏览器兼容性、分辨率兼容性、系统兼容性

## 自动化测试
### selenium

### selenium webdriver定位元素的方法
appium 中也有 webdriver 方法
by_id, by_name, class_name, xpath，根据 uiautomatorviewer 找到页面元素的 id name class xpath 等

### appium 原理
https://segmentfault.com/a/1190000018037362

### 开展自动化测试的方案，如何搭建自动化框架
1. 关于 APP ，需要安装配置环境和依赖，包括 JDK、 SDK、 python、 nodejs、 appium 等
2. 做好项目架构设计，用 PageObject 设计模式将页面元素与业务操作分离，分为页面层、操作层（分装各类页面操作）和业务层（执行各类页面操作）
3. 封装基本方法，如 appium 的启动关闭等、 打印日志、 获取设备信息、 基本操作方法（滑动、点击、放大等）、测试报告
4. 获取元素定位、 编写测试用例（yaml），一个测试用例对应一个操作方法
5. 执行测试用例， 得到测试报告

### 你理解的自动化测试
通过执行脚本自动测试软件，自动地实施软件的单元测试，功能测试，压力测试和性能测试等
1. 让自动化代替手动，减少一些手工测试的时间
2. 让每次回归或上线验证必须执行的测试用例优先自动化，减少重复劳动
3. 自动化测试和手工测试应该是相互补充的过程

### 自动化测试与手工测试
#### 自动化测试： 回归、接口、性能、单元
适用于做高并发操作，持续收集设备资源（CPU、内存、磁盘IO、网络带宽等），长时间稳定性测试（7x24小时）  
存在大量的回归测试工作，使用自动化测试可以减少手工测试人员的劳动强度，提高工作效率。

优点: 
1. 适合做回归测试，极大提高测试效率，缩短回归测试时间。
2. 可以运行更多更繁琐的测试，可以在较少的时间内运行更多的测试。
3. 可以执行一些手工测试困难或不可能进行的测试，如模拟大量用户的测试
4. 能够更好的利用资源，节省时间和人力
5. 测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。
6. 测试的复用性。由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例。
7. 增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。

缺点：
1. 不能取代手工测试，自动化测试不能提高有效性
2. 手工测试比自动测试发现的缺陷更多
3. 需要耗费一定的时间

#### 手工测试： 用户体验测试、界面、排版、色彩
优点： 测试人员具有经验和对错误的猜测能力、 审美能力和心理体验、 是非判断和逻辑推理能力。
缺点： 重复的手工回归测试，代价昂贵、容易出错； 依赖于软件测试人员的能力。


## 测试工具
自动化测试： selenium、appium
云测试： testin，用来测安卓兼容性
性能测试： loadrunner、 Locust（基于python）、jmeter
接口测试： postman
单元测试： unittest

## TDD
TDD 测试驱动开发: 是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。

优势：提高了单元测试的覆盖率、促成良好的代码设计

开发过程：
1. 添加测试用例。
2. 运行所有测试用例，如果新用例失败了，执行下一步，否则返回上一步。
3. 编写产品代码。
4. 运行所有测试用例，如果通过，执行下一步，否则返回上一步，直到写出满足测试用例的代码。
5. 重构。
6. 返回第一步，继续循环。

## 软件相关
### 软件生命周期
1. 软件计划与可行性研究阶段（问题定义、可行性研究）
2. 需求分析阶段
3. 软件设计阶段（概要设计和详细设计）
4. 软件编码阶段
5. 软件测试阶段
6. 软件运行与维护阶段

### 瀑布模型
瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，规定项目开发按照自上而下、相互衔接的固定次序进行。 计划、需求分析、系统设计、编码、测试、运行与维护。适合开发需求特别明确的任务。

### V 模型
瀑布模型的一个变体是 V 模型，质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系。
需求分析  <-- 验收测试
概要设计  <-- 系统测试
详细设计  <-- 集成测试
软件编码  <-- 单元测试

### 螺旋模型
螺旋模型是瀑布模型加上快速原型法发展而来，每次产生的新模型都是从之前的版本中提炼出来。
1. 确定本次迭代的目标和约束
2. 评估各种备选方案并确认，化解风险
3. 开发和验证本次迭代原型
4. 计划下一次迭代

### 敏捷开发
敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。每次迭代都是一个完整的软件开发周期，必须按照软件工程的方法论，进行正规的流程管理。

迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次、迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态。

采用"增量开发"来划分迭代，增量开发是软件的每个版本，都会新增一个用户可以感知的完整功能。增量开发加上迭代开发，才算真正的敏捷开发。

优势：
1. 早期交付，从而大大降低成本
2. 及时了解市场需求，降低产品不适用的风险 	

### 软件质量
软件质量是软件符合明确叙述的功能和性能需求、文档中明确描述的开发标准、以及所有专业开发的软件都应具有的隐含特征的程度。

一个注重产品质量的公司，就越注重测试，在需求分析结束后，测试人员就需要接入项目，根据需求分析进行功能测试用例的设计。编码前，架构设计质量必须得到保证；编码时，代码质量必须得到保证；编码后，测试质量必须得到保证。

影响软件质量的因素可以分为三组：
1. 产品运行： 正确性、健壮性、效率、完整性、可用性、风险
2. 产品修改： 可理解性、可维修性、灵活性、可测试性
3. 产品转移： 可移植性、可再用性、互运行性

软件质量的六个基本特征：
1. 功能特征：与一组功能及其指定性质有关的一组属性，这里的功能是满足明确或隐含的需求的那些功能。
2. 可靠特征：在规定的一段时间和条件下，与软件维持其性能水平的能力有关的一组属性。
3. 易用特征：由一组规定或潜在的用户为使用软件所需作的努力和所作的评价有关的一组属性。
4. 效率特征：与在规定条件下软件的性能水平与所使用资源量之间关系有关的一组属性。
5. 可维护特征：与进行指定的修改所需的努力有关的一组属性。
6. 可移植特征：与软件从一个环境转移到另一个环境的能力有关的一组属性。

### 问答题
#### 测试的流程：
1. 软件开发完成以后，就会把需求规格说明书、软件程序和软件源代码发过来；
2. 项目经理出测试方案（要使用什么样的测试方法、测试策略）安排测试计划（测试人员、资源、进度的安排，测试的范围和完成的目标）；
3. 测试人员编写和执行测试用例；
4. 提交缺陷并且进行跟踪；
5. 编写测试报告。

#### 测试的意义
尽量能多地发现软件产品中的缺陷，并对软件产品的质量水平做出尽可能准确的评估，进而保证产品质量，降低上线后的风险。

#### 如何管理测试
测试管理流程： 识别并定义需求（确保测试能够完全覆盖所有需求）、制定测试方案、开发测试用例、监视测试构建、计划测试执行和记录、跟踪测试工作。

可以使用一些测试管理软件： TestRail、禅道

### 测试环境搭建
测试环境 = 软件 + 硬件 + 网络 + 数据准备 + 测试工具
1. 确定操作平台，linux or win
2. 安装服务器和数据库，tomcat、oracle、mysql
3. 安装软件，配环境变量
4. ...

#### 测试未来的趋势怎么看
1. 我认为测试在未来地位会逐渐提升，并且测试对从业者的要求会越来越高，企业更多需要的是一些技术层级稍微高一点的人才
2. 软件测试的发展会逐渐加快，软件的缺陷会给企业带来巨大的直接经济损失，就比如去年拼多多的 bug
3. 未来测试越来越趋于自动化测试，但是手工测试也不会完全淘汰。

因为：
互联网相比于传统行业，更加注重用户体验，产品迭代快，需求变更快，测试周期短
信息安全敏感度高，安全测试要求高
用户量级大，更产品的性能测试、并发测试等
用户场景更多，更复杂，对兼容性测试、适配测试要求更高

#### 为什么不做开发做测试 、优势
1. 测试很重要，软件的缺陷会给企业带来巨大的直接经济损失，而测试能够保证产品的质量。
2. 看好自动化测试的发展空间和前景
3. 就个人而言，我认为自己比较细心，不浮躁，之前有测试经验也表明我可以找到一些别人找不到的 bug，喜欢发现 bug 时的成就感；
而且现在做得好的测试相对于开发来说较少，做测试，相比于开发、算法，我以后的发展前景也许更远；
测试的接触面比较广，产品和开发都会进行交流，可以更好的明确自己以后的职业规划。

#### 测试开发
测试开发的核心职能还是测试，但会通过开发的手段提升测试的效率，更快速的发现问题

测试开发并不是传统去做自动化用例的开发，他会去做一些测试平台、测试服务，或者一些测试基础架构的开发。做点白盒测试， 帮助测试组开发一些方便测试的小工具，弄个测试数据生成页面，弄个自动化测试框架，引进先进的测试技术，缩短一些测试时间啥的.

为什么会出现？因为软件越来越复杂，release周期越来越短，质量要求越来越高，人工越来越贵。另外手工测试也有很多局限性，比如没有办法在最短的时间内做到全平台和全功能的覆盖，手工测试也没办法像自动化测试一样全天24小时运行，并且可以在最短的时间内发现regression的bug，一些类型的测试比如性能和并发只能自动化的方式来做，这就必然导致自动化测试成为主要的测试方法，从而替代大部分的人工测试

#### 测试与开发本质区别
测试的关注本质是产品质量，开发的关注是功能的实现。测试要从整体上看产品。

#### 测试开发需要具备的能力
1. 知识层面： 软件测试基础理论知识、编程基础、计算机基础知识、自动化测试工具、测试框架
2. 能力：
- 业务分析能力，分析整体业务流程、分析被测业务数据、分析被测系统架构、分析被测业务模块、分析测试所需资源、分析测试完成目标；
- 缺陷洞察能力，一般缺陷的发现能力、隐性问题的发现能力、发现连带问题的能力、发现问题隐患的能力、尽早发现问题的能力、发现问题根源的能力；
- 团队协作能力，合理进行人员分工、协助组员解决问题、配合完成测试任务、配合开发重现缺陷、督促项目整体进度、出现问题勇于承担；
- 专业技术能力，掌握测试基础知识、掌握计算机知识、熟练运用测试工具；
- 逻辑思考能力，判断逻辑的正确性、对可行性逻辑分析、站在客观角度思考；
- 问题解决能力，技术上的问题、工作中的问题、沟通问题；
- 沟通表达能力，和技术人员、产品人员、上下级的沟通；
- 宏观把控能力，有效控制测试时间、有效控制测试成本、有效制定测试计划、有效进行风险评估、有效控制测试方向。
3. 热爱测试行业，对测试有一定激情

#### 测试人员的核心竞争力
提早发现问题，并能够发现别人无法发现的问题。

#### 你认为是 bug，但开发不认同怎么办？
1. 首先客观、严谨地告诉开发 bug 的判断理由，并明确开发说不是 bug 的理由
2. 对开发的理由进行验证：参照产品需求文档、产品说明、设计文档等，如果与文档中的不一致，则向开发提供明确的依据；如果没有文档依据，可以根据用户一般使用情况、与产品、开发、客户等相关人员讨论，确认是否为缺陷。
3. 具体问题具体分析：
如果开发认为不好重现，测试需要找到更简洁有效的重现规律
4. 如果无法说服开发，可以与测试经理、产品经理进行讨论确认，打成一致的解决方案。

#### 如何和开发沟通 bug
1. 首先是测试人员要专业，确定这确实是一个 bug，不要制造不存在的 bug，不要重复提交 bug
2. 每个 bug 要描述清楚，客观、严谨，bug 内容的步骤清晰可操作，根据步骤可以重现 bug， bug 的实际结果和预期结果要明确，可以截图说明、录制视频说明、附上错误日志等，降低开发修改 bug 时需要询问测试的频率
3. 问题集中起来反馈，当面沟通
4. 使用 bug 管理工具来提交和追踪

#### 实习时的功能测试怎么做
首先制定测试计划，然后进行测试设计，将在测试计划阶段指定的测试活动分解，进而细化，为若干个可执行程序的子测试过程，然后执行测试，按照测试计划使用测试用例对待测项目进行逐一的，详细的排查分析评估，最后对测试结果进行统计和分析

【参考文献】
[软件测试面试题整理](https://blog.csdn.net/lifuxiangcaohui/article/details/8897589)