<!-- GFM-TOC -->
* [指针和引用的区别](#指针和引用的区别)
* [进程 线程 协程](#进程-线程-协程)
	* [线程](#线程)
	* [进程](#进程)
		* [进程与线程的区别](#进程与线程的区别)
		* [进程通信与线程通信](#进程通信与线程通信)
		* [多进程](#多进程)
	* [协程](#协程)
* [死锁](#死锁)
* [CPU密集型和IO密集型](#CPU密集型和IO密集型)
* [缓存](#缓存)
* [其他](#其他)
	* [C中的字符串](#C中的字符串)
	* [ACL](#acl)
<!-- GFM-TOC -->

## 指针和引用的区别
1. 指针是一个实体，而引用只是别名
2. 引用必须被初始化，而指针不用
3. 引用初始化后不可以被改变，指针可以改变所指的对象
4. 不存在指向空值的引用，但存在指向空值的指针

## 进程 线程 协程
### 线程
1. 线程安全怎么保证（答：乐观锁，悲观锁）
乐观锁：在操作时很乐观，认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁。
但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或 CAS 算法实现。

悲观锁：总是假设最坏的情况，每次取数据时都认为其他线程会修改，因此每次拿数据都会加悲观锁。一旦加锁，不同线程同时执行时,只能有一个线程执行，其他的线程在入口处等待，直到锁被释放。

应用： MySQL 的读锁、写锁、行锁等； Java 的 synchronized 关键字

读多写少用乐观锁； 写多用悲观锁。

2. 如果有很多任务，创建线程越多越好吗？
答： 不是，进程的创建和销毁需要一定的开销，线程间的频繁切换会给 CPU 带来负担，

### 进程
#### 进程与线程的区别
一个程序至少有一个进程，一个进程至少有一个线程。

1. 根本区别：进程是资源分配的基本单位，线程是程序执行的最小单位
2. 开销方面：每个进程有独立的代码和数据空间，每启动一个进程，系统会为他分配地址空间，进程间的切换有较大开销；同一类线程共享代码和数据空间，切换和创建的开销较小
3. 线程通信更加方便，同一进程下的线程共享全局变量、静态变量等数据；而进程需要以通信方式(IPC)进行
4. 由于进程有自己独立的地址空间，因此多进程程序更加健壮；而多线程程序有一个线程挂掉，全部线程都会挂掉

#### 进程通信与线程通信
线程通信： 同一进程下的线程共享相同的数据空间，可以直接通信。 需要做好同步/互斥 mutex，保护共享的全局变量。

进程通信： 需要通过操作系统，以 IPC 方式进行。
1. 管道： 是半双工通信方式，数据只能单向流动，只能在父子进程或者兄弟进程中使用。 
2. 命名管道： 是半双工的通信方式，但允许无亲缘关系进程间的通信。 命名管道是一种 FIFO 对象，常用于客户端-服务器通信。
3. 消息队列： 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 信号量： 是一个计数器，用于为多个进程提供对共享数据对象的访问。
5. 共享内存： 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式。需要使用信号量用来同步对共享存储的访问。
6. 套接字： 与其它通信机制不同的是，它可用于不同机器间的进程通信

#### 进程的状态
在 linux 中进程有 R、S、D、T、Z、X

1. R (running)，可执行状态，只有该状态的进程能在 CPU 上运行
2. S (sleeping)， 休眠状态，可中断，常因为等待某个操作而被挂起，放入对应事件的等待队列中
3. D (disk sleep)， 不可中断的睡眠状态，进程不响应异步信号，kill -9 不能杀死，
4. T (stopped)，暂停状态
5. t (tracing stop)，跟踪状态，如在 gdb 中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于 TASK_TRACED 状态。
6. X (dead)，退出状态
7. Z (zombie)，僵尸进程

#### 孤儿进程和僵尸进程
子进程和父进程的运行是异步过程，即父进程永远无法预测子进程何时结束。当子进程完成工作终止后，父进程需要调用 wait() 或 waitpid() 系统取得子进程的终止状态。

##### 孤儿进程
- 一个父进程退出，而他的子进程还在运行，那么这些子进程将成为孤儿进程。
- 孤儿进程没有父进程，会被 init 进行（pid=1）收养，并由 init 进程对他们完成状态收集工作。 
- 孤儿进程不会对系统造成危害。

##### 僵尸进程
- 一个进程使用 fork 创建子进程，如果子进程退出，而父进程没有调用 wait() 或 waitpid() 获取子进程的状态信息，那子进程的进程描述符仍保留在系统中，成为僵尸进程。
- 子进程在 exit() 后并非马上消失，而是留下一个僵尸进程(zombie)的数据结构，等待父进程处理。若父进程没来得及处理，用 ps 查看子进程会显示状态 “Z”
- 系统能使用的进程号有限，如果产生大量僵尸进程，就可能因为没有可用进程号而不能产生新进程。
- 消灭僵尸进程： kill 父进程，那僵尸进程将变为孤儿进程，由 init 收养，init 会释放僵尸进程占用的资源。

#### 进程调度
创建一个线程和一个进程分别创建在哪里的？？？ 什么意思？
APP是用多进程安全还是用多线程安全？？？
windows 和 linux 调度进程咋回事， window，linux怎么启动一个线程？？？

### 协程
协程 Coroutine：又称微线程，纤程。是一种程序组件，协程看上去是子程序（函数），但在执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  
特点：只有一个线程执行。  
优势：执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗；不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。  
python generator 的 yield 可以在一定程度上实现协程。

- 线程由操作系统控制
- 协程由程序自身控制

## 死锁
当两个或两个以上的进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，造成死锁

### 死锁产生的必要条件
1. 互斥条件： 资源分配是排他性的，每个资源只能同时给一个进程使用
2. 不可剥夺条件： 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能进程自己主动释放
3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4. 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

### 解决死锁的方法
1. 死锁预防

2. 死锁避免

3. 死锁解除

## CPU密集型和IO密集型
**CPU 密集型**    
- 也叫计算密集型任务，特点：需要进行大量判断，主要消耗 CPU 资源，大部分时间用于计算、逻辑判断等 CPU 动作的程序，如计算圆周率、视频高清解码等；  
- python 这种脚本语言不适合计算密集型任务，最好用 C 语言；
- python CPU 密集型任务用多进程模型。
  
**IO 密集型**
- 涉及到网络、磁盘 IO 的任务是 IO 密集型任务，特点：CPU 消耗较少，大部分时间在等待 IO 操作完成（IO 操作速度远低于 CPU 和内存的速度）， 如 web 应用；
- IO 密集型任务最合适的语言是开发效率最高（代码量最少）的语言，脚本语言是首选；
- python IO 密集型任务用多线程模型，多线程只使用一个 CPU 核心。


## 其他
### C中的字符串
在 C/C++ 中的每个字符串都以字符 '\0' 结尾，因此每个字符串都有一个额外字符的开销，把一个长度为 10 的字符串 '0123456789' 需要放到一个长度为 11 的数组中才不会越界。 但 python 中无此规定。

### ACL
ACL(Access Control List) 访问控制列表，包含了对一个对象或一条记录可进行何种操作的权限定义。

为了保证内网的安全性，需要通过安全策略来保障非授权用户只能访问特定的网络资源，从而达到对访问进行控制的目的。简而言之，ACL 可以过滤网络中的流量，是控制访问的一种网络技术手段。

### 面对对象和面对过程的区别
面向过程： 是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

面向对象： 是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
面向对象的主要思想：基于抽象数据类型的

## 缓存
缓存的概念、替换缓存的方式

## 大端小端
计算机的字节顺序模式分为大端数据模式和小端数据模式，它们是根据数据在内存中的存储方式来区分的。

小端字节顺序的数据存储模式是按内存增大的方向存储的，即低位在前高位在后；大端字节顺序的数据存储方向是高位在前，低位在后。

比如十进制数 9877，如果用小端存储表示则为： 
   高地址 <- - - - - - - - 低地址 
10010101[高序字节] 00100110[低序字节] 

用大端存储表示则为： 
   高地址 <- - - - - - - - 低地址 
00100110[低序字节] 10010101[高序字节]

优点： 
小端存储：便于数据之间的类型转换，例如：long 类型转换为 int 类型时，高地址部分的数据可以直接截掉。 
大端存储：便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。

用途： 
小端存储：常见于本地主机上(也有部分类型主机为大端存储)。 
大端存储：常见于网络通信上，网际协议TCP/IP在传输整型数据时一般使用大端存储模式表示,例如 TCP/IP 中表示端口和 IP 时，均采用的是大端存储。



