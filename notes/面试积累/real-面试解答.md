## 20181215 字节跳动一面 50分钟
### 1. 找出数组中第 k 大的数，Kth Largest 
其实相当于 求数组中最大的前 K 个数，topK 问题

应该提出疑问：是否可以改变输入的数组？

可以改变输入数组：  
思路： 以第一个数为基准，用一次快速排序找到他的正确位置，下标为 mid，则 mid 左边的数小于等于基数，mid 右边的数大于等于基数，可以知道 nums[mid] 是第 len(nums)-mid 大的数，有无重复数字都可以这样做  
平均的时间复杂度为 O(n)， 最好的时候一次 O(1)，最差的时候 ？？？
```python
def topk(nums, k):
    n = len(nums)
    if k > n or k <= 0:
        return None
    left, right = 0, n-1
    while left <= right:
        mid = quick_sort(nums, left, right)
        if mid == n-k:
            return nums[mid]
        elif mid > n-k:
            right = mid - 1
        else:
            left = mid + 1

def quick_sort(nums, left, right):
    key = nums[left]
    while left < right:
        while left < right and nums[right] >= key:
            right -= 1
        nums[left] = nums[right]
        while left < right and nums[left] <= key:
            left += 1
        nums[right] = nums[left]
    nums[left] = key
    return left
```

如果需要返回最大的前 K 个数，需要按照从大到小的顺序排列，知道了最大的第 K 个数的下标后，返回其左边的数组即可。
  
若直接排序，则时间复杂度为 O(nlogn)
用最大堆可以将时间复杂度降到 O(nlogk), 适合处理海量数据
```python

```

### 2. 上述问题用一次堆排序的时间复杂度，快排加二分实现的时间复杂度
一次堆排序时间复杂度 O(logn)，总的O(nlogn)

### 3. python 实现多并发用的进程还是线程，进程和线程的区别

提问： 是使用 CPU 密集型还是 IO 密集型？

对于 python， 若为 CPU 密集型应用多进程模型，需要大量的计算；  
若为 IO 密集型应用多线程模型，需要数据的读取写入、网络 IO 数据传输。  

进程和线程的区别：  
1. 根本区别：进程是资源分配的基本单位，线程是程序执行的最小单位
2. 开销方面：每个进程有独立的代码和数据空间，每启动一个进程，系统会为他分配地址空间，进程间的切换有较大开销；同一类线程共享代码和数据空间，切换和创建的开销较小
3. 线程通信更加方便，同一进程下的线程共享全局变量、静态变量等数据；而进程需要以通信方式(IPC)进行
4. 由于进程有自己独立的地址空间，因此多进程程序更加健壮；而多线程程序有一个线程挂掉，全部线程都会挂掉

### 4. tcp 和 udp 的区别，传输过程有什么不同，tcp的数据能够一次接收吗
tcp 和 udp 的区别：  
1. TCP 发送数据前需要建立连接； UDP 不需要
2. TCP 更可靠、稳定，但是效率较低，有延时，占用系统资源高； UDP 传输速度快，但不可靠、不稳定，可能丢包
3. 对网络通信质量有要求，数据准确时用 TCP，如浏览器、邮箱等； 不高、要求快用 UDP，如 QQ语音、视频
4. **本质区别： TCP 面向字节流，UDP 面向报文**  
TCP 通过字节流传输，有窗口大小限制，太长的话会被拆分进行发送
UDP 通过报文传输，无论交给 UDP 多长的报文都会一次性发送，会保留报文的边界，不合并不拆分

传输过程有什么不同，tcp的数据能够一次接收吗？？？不明白是什么？？？

### 5. 数据库怎么判断一个字段是否需要建索引，索引用的什么数据结构
- 较频繁的作为查询条件的字段应该创建索引
- 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
- 更新非常频繁的字段不适合创建索引
索引的数据结构：B+树、B-树、通信R-树、散列  
大部分数据库系统及文件系统都采用 B-树 或 B+树 作为索引结构，B-树索引实现是一个专门为范围查询设计的，散列实现对直接查询方式能提供最优性能，但对一定范围的查找却效率低下。

### 6. 什么是事务，事务出错的如何回滚，保证正确
事务: 数据库运行的逻辑工作单位，是用户定义的一组操作序列，要么完全执行，要么完全不执行。  
ACID：原子性、一致性、隔离性、持续性

### 7. 栈和堆在程序上的区别
**堆栈空间分配：** 
- 栈区 stack： 由编译器自动分配释放，存放函数的参数值、局部变量的值等，操作方式类似数据结构中的栈 
- 堆区 heap： 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。不是数据结构中的堆，分配方式类似于链表

**堆栈缓存方式：**
- 栈使用一级缓存，通常是被调用时处于存储空间中，调用完立即释放
- 堆使用二级缓存，生命周期由虚拟机的垃圾回收算法来决定，因此调用速度更低一些

void f() { int* p=new int[5]; }   
new：分配了一块堆内存
指针p：分配一块栈内存  
因此，上述为在栈内存中存放一个指向一块堆内存的指针 p。 程序先确定在堆中分配内存的大小，然后调用 operator new 分配内存，然后返回这块内存的首地址，放入栈中。

### 8. python 的 is 和 == 的区别
python 对象包括三个基本要素，身份标识 id、 数据类型 type、 值 value  
is 和 == 都是用于用于对象的比较判断，但判断内容不相同。
- is 同一性运算符，比较两个对象的 id 是否相同。 当 a 和 b 的值相同时，只有数值型和字符型，**并且在通用对象池中的情况下**， a is b 为 True； 而 tuple，list，dict，set 时，a is b 为 False。 对于浮点数，只有正浮点数值相等时 a is b 为 True
- == 比较两个对象的值是否相同
- id(object) 查看 object 所在的内存地址

备注： 事实上 python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。只有数值在 [-5,256] 之间时同一个数值的 id 才会相等，超过范围就是 Fasle。同理，字符串对象也有类似的缓冲池。

### 9. python 中正则的 search 和 match 区别，正则怎么实现过程如何
match() 在 string 的开始位置匹配，如果不匹配，返回 None，只有在 0 位置匹配成功才有返回  
search() 扫描整个 string 查找匹配，全部没有返回 None

### 10. 一个很大的文本，比如log数据，以行存储，如何快速计算一个字段的平均值


