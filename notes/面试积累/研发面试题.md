## 小米
1.中文数字转阿拉伯数字，如“一百五十万九千零二十一”转为“1509021”
```python
def chinese2digit(s):
    dict = {'零':0, '一':1, '二':2, '三':3, '四':4, '五':5, '六':6, '七':7, '八':8, '九':9, '十':10, '百':100, '千':1000, '万':10000, '亿':100000000}
    res = 0
    r = 1 # 十，百，千，万，亿的时候
    tmp = 0 # 在 r 前面有比其小的时候， 如 一百五十万， 100要和10000相乘，而不是和十万相乘
    for i in range(len(s)-1, -1, -1):
        num = dict[s[i]]
        if num >= 10 and i == 0:
            res = res + num
        elif num >= 10:
            if num > r:
                r = num
                tmp = 0
            else:
                tmp = num * r # 当出现 一百五十万 的时候
        else:
            if tmp:
                res = res + num * tmp
            else:
                res = res + num * r
    return res
```

2.Leetcode 174：M * N 的格子，格子里有整数，玩家需要从左上走到右下，每次只能向右或者向下，走到对应格子，将其中数字累加到 HP 上，如 HP<=0，游戏中止。问最小初始 HP 值是多少。  
  
思路：用 dp[i][j] 表示到达第 (i,j) 格子前所需要的最小能量,从右下向左上填充格子。  
在 (i,j) 时, 向下走，到达(i+1,j) 时会获得的能量为：dp[i+1][j] = dp[i][j] + dungeon[i][j]，  
因此 dp[i][j] = dp[i+1][j] - dungeon[i][j]， 但至少需要 1，因此 down = max(1, dp[i+1][j]-dungeon[i][j])

```python
def calculateMiniumHP(dungeon):
    m = len(dungeon)
    n = len(dungeon[0])
    dp = [[0 for j in range(n)] for i in range(m)]
    dp[-1][-1] = max(1, -dungeon[-1][-1]+1)

    for i in range(m-1, -1, -1):
        for j in range(n-1, -1, -1):
            down = None
            if i < m-1:
                down = max(1, dp[i+1][j]-dungeon[i][j])
            right = None
            if j < n-1:
                right = max(1, dp[i][j+1]-dungeon[i][j])
            if down and right:
                dp[i][j] = min(down, right)
            elif down:
                dp[i][j] = down
            elif right:
                dp[i][j] = right
    return dp[0][0]
```

3.建一个栈
栈是“先进后出”结构，进栈和出栈操作都在同一端，即栈顶。  
用 python 实现栈，应该包括 Stack() 新建一个栈， push(item), pop() 出栈， peek() 返回栈顶，isEmpty() 判断是否为空， size() 获取栈大小。 
```python
class Stack():
    def __init__(self):
        self.stack = []
    def isEmpty(self):
        return self.stack == []
    def push(self, item):
        self.stack.append(item)
    def pop(self):
        self.stack.pop()
    def peek(self):
        return self.stack[-1]
    def size(self):
        return len(self.stack)
``` 

4.跳台阶问题，掌握变种  
- 简单跳台阶，斐波拉切数列，f(n) = f(n-1) + f(n-2)
```python
def climb_stairs(n):
    if not n: return 0
    a = 1
    b = 1
    for i in range(1, n):
        tmp = a
        a = a + b
        b = tmp
    return a
```
- 变态跳台阶  
一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
```python
def climb_stairs(n):
    if not number: return 0
    dp = [1]
    for i in range(1, number):
        f = sum(dp)
        dp.append(f)
    return sum(dp)
```
可简化，实际上当 n >= 2 时，f(n) = 2 * f(n-1)   
f(n-1) = f(0) + f(1) + ... + f(n-2)  
f(n) = f(0) + f(1) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)  

5.  给定一个整数序列,求出连续子序列的最大和  
实际为 Leetcode 53：Maximum Subarray，利用动态规划。  
```python
def maxSubArray(nums):
    dp = -float('inf')
    max_sum = dp
    for i in range(len(nums)):
        dp = max(dp+nums[i], nums[i])
        max_sum = max(dp, max_sum)
    return max_sum
```

如果想返回子数组的下标：
```python
def maxSubArray(self, nums):
    dp = -float('inf')
    max_sum = dp
    start_dp, end_dp, start, end = 0, 0, 0, 0
    for i in range(len(nums)):
        dp += nums[i]
        if dp < nums[i]:
            start_dp, end_dp = i, i
            dp = nums[i]
        else:
            end_dp = i
        if max_sum < dp:
            max_sum = dp
            start = start_dp
            end = end_dp
    return max_sum, start, end
```

6. [Lintcode 45: Maximum Subarray Difference](#https://www.lintcode.com/problem/maximum-subarray-difference/description)  
给定一个整数序列,求出两个不重叠的连续子序列和之差的最大绝对值  
思路：将数组划分为左右不重叠的两个部分，分别求左边的最大子序列和 left_max 和右边的最小子序列和 right_min，相减得到最大差值; 或者求左边的最小子序列和 left_min 和右边的最大子序列和 right_max，相减得到最大差值。
  
最小子序列和可以通过最大子序列和得到，将数组中的全部元素取反，得到最大子序列和，再将结果取反即为最小子序列和。  
对于 nums = [2,-1,-2,1,-4,2,8]  
若分为两部分，left_max = [2,1,-2,1,-4,2,10], right_min = [8,2,-4,-3,-5,-6,-4]
那么 left_max[i] 对应的就是 right_min[len(nums)-i-2]

```python
class Solution:
    def maxDiffSubArrays(self, nums):
        def maxDiffSubArrays(self, nums):
        if len(nums) <= 1:
            return 0
        res = float("-inf")
        left_max = self.maxSubArrays(nums)
        negative_nums = [-num for num in nums]
        right_min = [-num for num in self.maxSubArrays(negative_nums[::-1])]
        
        left_min = [-num for num in self.maxSubArrays(negative_nums)]
        right_max = self.maxSubArrays(nums[::-1])

        for i in range(len(nums)-1):
            res = max(res, abs(left_max[i] - right_min[len(nums)-i-2]))
            res = max(res, abs(left_min[i] - right_max[len(nums)-i-2]))
        return res

    # 最大子段和，返回子数组
    def maxSubArrays(self, nums):
        max_sum = []
        dp = -float('inf')
        for i in range(len(nums)):
            dp = max(dp+nums[i], nums[i])
            max_sum.append(dp)
        return max_sum
```

7. [Lintcode 139: Subarray Sum Closest](https://www.lintcode.com/problem/subarray-sum-closest/description)  
给定一个整数序列,求出子段序列和最接近 0 的连续子序列
思路：  
1. 对于 nums[i] 求出 nums[0] 到 nums{i] 的和，用 pairs 存储和及下标  
2. 根据和排序，那么左右相邻的是相近的子序列和  
3. 寻找两个最相近的子序列和，那么在原数组中，这两个子序列的差异部分的和会最接近 0，返回左右的 index
```python
def subarraySumClosest(self, nums):
    if not nums:
        return None
    if len(nums) == 1:
        return [0, 0]
    pairs = [[nums[0], 0]]
    for i in range(1, len(nums)):
        pairs.append([nums[i]+pairs[i-1][0], i])
    pairs = sorted(pairs, key=lambda x: (x[0], x[1]))

    min_diff = float('inf')
    start, end = -1, -1
    for i in range(1, len(nums)):
        if abs(pairs[i][0]-pairs[i-1][0]) < min_diff:
            min_diff = abs(pairs[i][0]-pairs[i-1][0])
            start = min(pairs[i][1], pairs[i-1][1]) + 1
            end = max(pairs[i][1], pairs[i-1][1])
    return [start, end]
```

8.Leetcode 143：input : a0->a1->a2->....->a(n-2)->a(n-1)    output: a(0)->a(n-1)->a(1)->a(n-2)  
```python
def reorder_list(head):
    if not head or not head.next or not head.next.next: # 一定不要忘记边界条件
        return head
    slow = fast = head
    # 首先拆分两个链表
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    p, q = head, slow.next
    slow.next = None # 拆分成两个链表后，别忘记将 slow 置为 None
    # 反转第二个链表
    pre = None
    cur = q
    while cur:
        tmp = cur.next
        cur.next = pre
        pre = cur
        cur = tmp
    q = pre
    # 合并两个链表
    dummy = ListNode(0)
    dummy.next = p
    while p and q:
        tmp = p.next
        p.next = q
        q.next = tmp
        p = p.next
        q = q.next
    return dummy.next
```

9.判断单链表是否有环？如何找到环的“起始”点？如何知道环的长度？
```python
# 快慢指针法
def is_circle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return Fasle

def find_circle(head):
    slow = fast = head:
    circle_len = 0
    flag = 0
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        circle_len += 1
        if slow == fast:
            flag = 1
            break # 别忘记退出循环
    if flag == 0:
        return False
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    return slow, circle_len
```

10.100 瓶水，中间有一瓶有毒，有一批小老鼠可以试验，老鼠喝了毒水一个小时就会死，请问一个小时找出有毒的水至少需要多少老鼠；两个小时内找出有毒的水至少需要多少老鼠。

11.ABCDE五个囚犯抓100颗绿豆，最少抓0颗，最多抓100颗，从A开始抓，依次到E最后抓，最后拿到数量最多的和数量最少的处死。若有同为最多或者同为最少的，一并处死。条件：五个囚犯都很聪明，也都很自私，并且互相不信任，都优先自保，谁的存活的几率大？

## 字节跳动
- 二维数组搜索是否有 toutiao 这个单词, leetcode 79, 回溯，OK
- 二叉树前序遍历, OK
- 输入数字，如 11105，输出反向，50111， divmod，OK
- 一个数组中所有数均不重复，要求找出数组中任意一个峰值即可（一个数大于它左边的数且大于它右边的数），要求时间复杂度低于O(n)（不包含O(n)）。 二分查找，OK
- 全排列的算法，回溯，OK
- 2sum，哈希表，OK
- 输出"abcd"的全排列, OK


- BST 找第三大节点，然后时空优化  
只知道最简单的方法，中序遍历，右根左，再用一个计数器
- 两个很大的用链表表示的数组, 如何做两个链表的加法  
先反转链表，链表要从前面开始计算，最前面代表了个位的数字。一次遍历，记住循环的条件 while l1 or l2 or carry
- 一个有序单链表，头尾衔接成环，在不改变大小顺序的情况下插入一个新数字  
不难，考虑清楚三种情况，需要注意的是空链表时，需要创建一个新的只有一个节点的循环链表，指向自身




- 在一个游戏里每秒更新一次参与者分数排序，用什么排序算法最好，为什么？
- TopK 问题，如何证明一个算法最优
考察堆排序

7. 用rand3实现rand7
5. 有0-9，10个数字，排成圆环，从0开始走，一次走一步，可顺时针逆时针，问走n步回到0有几种走法；  
面编程题，10个格子排成一条，从某格子出发，每次可以向左或向右走一步，给定步数k问有多少种走法可回到原点。
10. 0-9a-z的字符36进制数加法； 不会
11. 实现lru缓存，要求get，set时间复杂度均为O（1）； 不会
7. 一个数组里面有且只有两个一样的数,如何把这个数找出来



redis，mysql，http
hashmap的结构，手写数据库查询语句以及索引优化，redis等缓存的使用

1. vim 及 linux 常用指令
2. gdb 调试
3. 指针和引用的区别
4. select 和 epoll 区别
5. 进程和线程区别
6. 
.域名解析过程，IP由DNS服务器解析出来，DNS用UDP协议，HTTP的PORT默认是80，用到了TCP建立三次握手连接，数据链路层查找MAC地址用的ARP协议（但这个协议实际是网络层的）。

1.TCP和UDP深入追问，TCP是针对字节流的，UDP是针对报文的，他们的本质区别是什么？即字节流和报文在发送和接收数据方面有什么不一样的地方？
TCP由于有窗口大小的限制，所以发送端发送过来的数据如果过大，不能一次性全部接收，而应该循环接收，直至全部接收；而UDP则没有这种限制，发送端发多少，接收端就可以收多少。

.MySQL索引有哪些？左前缀索引是什么样的概念？在什么样的情况下索引会失效？

4.MySQL的引擎有哪些？有什么区别？

5.redis的数据类型有哪些？各适用于什么场景？

9. 装饰器在什么情况下使用, OK，想给函数增加额外的功能，但又不改变函数的代码的情况下