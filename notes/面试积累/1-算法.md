## 海量数据处理问题
方法：
1. 分治/hash映射 + hash统计 + 堆/快速/归并排序
2. Bloom filter: 可以用来实现数据字典，进行数据的判重，或者集合求交集，允许有一定错误的情况
3. Bitmap
4. Trie树： 数据量大，重复多，但是数据种类小可以放入内存
6. 数据库索引： 大数据量的增删改查
7. 倒排索引： 搜索引擎，关键字查询；用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。
8. 外排序： 大数据的排序，去重； 归并排序
9. 分布式处理之Hadoop/Mapreduce：
10. 双层桶划分

[教你如何迅速秒杀掉99%的海量数据处理面试题](https://blog.csdn.net/v_july_v/article/details/7382693)

### python 读取大文件
```python
with open("test.txt", 'rb') as fr: # 用二进制读取是最快的方式
	for line in fr: # 一行行的读，不会全部加载到内存中
		pass
```

### TOPK 大数据的排序
1） 海量数据中找出最大的 k 个数
2） 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词
3） 有一个 1G 大小的一个文件，里面每一行是一个词，词的大小不超过 16 字节，内存限制大小是 1M。返回频数最高的 100 个词。

思路：都是要先统计出每个元素的出现次数，再用 TOPK 去求最大的 k 个数。
1. 对于有内存要求的，需要将大文件划分为小文件： 顺序遍历这个 1G 的大文件中的每个词，计算 hash(x)%2000，按照得到的值分别存储到 2000 个小文件中（x0,x1,...x1999），这样得到的每个文件大小大概是 500k，如果发现有文件大于 1M，就再按照这个方法进行划分，直到所有小文件都小于 1M
2. 对每个小文件，用 dict 统计每个词出现的频率（文件大小小于内存，可以直接计算，也可以用 tire 树）
3. 对每个小文件，用堆排序方法选出频率最大的 100 个词（TOPK 用最小堆），并存入一个文件中，这样就得到了 2000 个文件
4. 合并小文件，两两合并选出 200 个词中的前 100 个词（类似归并）

### 找出现次数最多的数
海量日志数据，提取出某日访问百度次数最多的那个IP（其实和 TOPK 一样）

思路： IP 是 32 位，总共有 2^32 个不同的 IP，每个 IP 大小为 4 个字节，2^32 * 4 = 16G，很难全部加载到内存中，因此考虑分治。（1G = 2^10M = 2^20KB = 2^30B）

1. 顺序遍历每个 IP，计算 hash(ip)%1000，分到 1000 个小文件（具体分多少个文件，还是要可用内存大小）
2. 然后构建一个 key-value 的哈希表（python 直接用 Counter 计数），找到最大的数，这样得到 1000 个出现最多的 IP
3. 从 1000 个 IP 中找到出现次数最多的

### 两个文件 a 和 b，各存放 50 亿条 URL，每条 URL 占用 64 字节，内存限制是 4G，找出 a,b 文件共同的 URL
估计每个文件大小为 50亿 * 64k 约等于 320G，远大于内存 4G，因此不可能将其完全加载到内存中处理，考虑分治。
1. 遍历文件 a，对每个 url 求 hash(url)%1000，根据得到的值把 url 分别存储到 1000 个小文件中(a0,a1,...a999)
2. 遍历文件 b，同样把 b 中的 url 分别存储到 1000 个小文件中(b0,b1,...,b999)
3. 求每对小文件 ai 和 bi 中相同的 url，可以用 set 存储 ai 的 url，然后遍历 bi 中的每个元素，找到相同的就记录下来。

1-2 步处理后： 所有可能相同的 url 就会被分到对应的小文件中，也就只要去找 a0 和 b0 中相同的 url，ai 和 bi 中相同的 url。 因此相同的 url 的 hash 值是相同的，hash 是随机的，因此理论上可以看到平均分配。

### 一个大文件，包含一些列搜索关键词，给定一个关键词，如何判断是否在这个大文件中
有一个大文件，里面含有一些列搜索关键词，如何判断一个给定的关词是否包含在内（使用哈希表），使用什么哈希函数，是否存在冲突，如何解决冲突. 在上述的基础上，数据中还包含ip，时间段，如何根据ip查找相应关键词以及时间段，如何根据关键词查找某个时间段内的所有ip

使用 hash 来判断

在允许一定错误的情况下，可以用布隆过滤器，遍历文件的每个词，使用 k 个哈希函数将元素映射到位数组中，用 k 个映射位是否全为 1 来表示元素是否在集合中。

### 一个很大的文本，比如 log 数据，以行存储，如何快速计算一个字段的平均值
按行切分文件： linux 中的 split 命令
```sh
wc -l big.txt # 先计算出文件的行数
split -l 10000 big.txt -d -a 4 small_ # 切分为前缀为 small_ 的小文件，每个 10000 行，-d 系数是数字，-a 4 后缀系数为四位数
```

## 链表
### 两个无序链表合并成有序链表，并去除重复的节点
方法一： 若没有特殊要求，可以创建新的链表，并允许使用数组的情况下，可以先把链表节点的值存入数组中，再用 set 去除重复数字，然后按照数组排序的方法，再将排序后的数组转为有序链表

方法二： 只能在原链表的基础上进行排序操作，先用插入排序对无序链表进行排序，再进行一次二路归并。
```python
def merge_list(head1, head2):
	head1 = insert_sort(head1)
	head2 = insert_sort(head2)
	dummy = ListNode(0)
	pre = dummy
	while head1 and head2:
		if head1.val <= head2.val:
			pre.next = head1
			head1 = head1.next
		elif head2.val < head1.val:
			pre.next = head2
			head2 = head2.next
		pre = pre.next
	if head1:
		pre.next = head1
	if head2:
		pre.next = head2
	head = dummy.next
	return delete_repeat(head)

def insert_sort(head):
	if not head or not head.next:
		return head
	dummy = ListNode(0)
	dummy.next = head
	cur = head
	while cur.next:
		if cur.next.val >= cur.val:
			cur = cur.next
		else:
			pre = dummy
			target = cur.next
			while pre.next.val <= target.val:
				pre = pre.next
			cur.next = cur.next.next
			tmp = pre.next
			pre.next = target
			target.next = tmp
	return dummy.next

def delete_repeat(head):
	if not head or not head.next:
		return head
	cur = head
	while cur:
		while cur.next and cur.next.val == cur.val:
			cur.next = cur.next.next
		cur = cur.next
	return head
```

方法三： 如果要求时间复杂度为 O(nlogn)，则可以用归并排序的思想对无序链表进行排序

### 双向链表插入节点


## 数学
### 因数分解

### 求 1-n 中的所有质数

### 求质数和

### 开根号的过程

### 求100-999水仙花数

### x介于-100到100之间，n是有符号的整数介于-2^31-1到2^31-1之间，求x^n，写出函数求解过程

### 求n的阶乘中0的个数

### a=0  b=1……  z=25 aa=26  1024是多少

### 用英文字母a-z来分别表示数值0-25, 形成一个26进制的数值表示法。需要你写一个方法，将用a-z表示的26进制数值的字符串，转化为对应的10进制数值。

## 字符串
### 两个字符串的最长公共子串

### 判断一个字符串是否为另一个字符串子串

### 最长相同的子串一个字符串

### 在字符串中找出不重复字符的个数，找出一个字符串的最长不重复子串

### 求字符串中回文字符串。

### strcpy的实现

### 给定一个字符串，如何判断是否是有效的ipv4，针对所写代码设计测试用例

### 给定一个字符串（全字母），将字符串里的字符按字母升序排列。

### 判断很多单词是否能构成环 用到栈

### ### 读一个文件 找出出现次数最多的字符串


## 数组
### 找无序数组中第k个数

### 两数之和

### 找出两个只出现一次的数字，其余的数字都出现了两次

### 给你一个数组，如果某一个数出现次数超过一半，怎样快速找出这个数

### 给你一个数n，求出所有和等于n的可能，比如n等于5，可能的序列就有 1 2 2,1 1 3…

### 连续子数组最大和

### 子序列最大和

### 一个数组求出现奇数次的数字

### 个m * n的矩阵，从左上角出发，走到右下角终止，每次只能向右或向下前进，求一共有多少种走法。

### n个数，无序，本是1.2.....n，从中抽出两个数，给你n-2个数，怎么找到抽出的两个数

### 两个序列a，b，可以交换序列中的元素，使得最后两个序列元素之和的差值的最小。

### 把后m个数移动到前面，不用辅助空间，不改变顺序

## 二叉树
### 有一棵二叉树，树上每个点标有权值，权值各不相同，请设计一个算法算出权值最大的叶节点到权值最小的叶节点的距离。二叉树每条边的距离为1，一个节点经过多少条边到达另一个节点为这两个节点之间的距离。

### 给定二叉树的根节点root，请返回所求距离。

## 其他
### 模拟一副扑克牌的洗牌过程

### 写了一个程序，有个小球，球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10 次落地时，共经过多少米？第 10 次反弹多高？

### 火车售票系统是早7点-晚23点进行网上售票，写一个程序判断是否可以进行网上买票

### 六位数字旋转180°正常的概率，和原来一样的概率？？？

## 能做出来
### 求全排列
```python
def function(nums):
	size = len(nums)
	res = []
	def dfs(n, arr):
		if len(arr) == size and arr not in res:
			res.append(arr)
			return 
		for i in range(len(n)):
			dfs(n[:i]+n[i+1:], arr+[n[i]]) # 注意要是数组形式 [n[i]]
	dfs(nums, [])
	return res
print(function([1,2,3]))
```

如果有重复数字，提高效率的方法： 先对数组排序，那么重复数字会连在一起，当发现下一个数字是重复的，就跳过，因为会和前面的结果一样。

###