# 计算机网络
<!-- GFM-TOC -->
* [应用层](#应用层)
* [传输层](#传输层)
	* [TCP 和 UDP](#tcp-和-udp-区别)
	* [TCP 三次握手](#tcp-三次握手)
	* [TCP 四次挥手](#tcp-四次挥手)
* [HTTP](#http)
<!-- GFM-TOC -->

## 应用层
### 从输入 URL 到浏览器显示页面发生了什么？

可以分为两个阶段，网络通信和页面渲染。  
网络通信：  
1. 应用层 DNS 解析域名，找到对应的 IP 地址。 先本地再请求上级 DNS 服务器
2. 应用层客户端发送 HTTP 请求
3. 传输层 TCP 传输报文，HTTP 是包裹在 TCP 报文之中  
三次握手： SYN, ACK/SYN, SYN  
四次分手： FIN, ACK, FIN, ACK  
4. 网络层 IP 协议查询 MAC 地址：  IP 协议的作用是把 TCP 分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的 MAC 地址，也就是物理地址。IP 地址和 MAC 地址是一一对应的，一个网络设备的 IP 地址可以更换，但是 MAC 地址一般固定不变。ARP 协议可以将 IP 地址解析成对应的 MAC 地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的 MAC 地址来搜索下一个中转目标。
5. 数据到达数据链路层。 客户端发送请求完成
6. 服务器接受数据，处理请求并返回 HTTP 报文。 状态码 200 表示成功， 301 重定向， 400 not found
7. 页面渲染

### DNS 用的什么协议？
DNS 占用 53 号端口，同时使用 TCP 和 UDP 协议。  
1. DNS 区域传输使用 TCP 协议，需要进行数据同步，TCP 是可靠连接，可以保证数据的准确性  
2. 域名解析使用 UDP 协议，DNS 服务器负载低，响应快

### 域名解析过程
1. 本地 DNS 服务器收到 DNS 请求后，先查询自己的缓存记录，如果有，直接返回对应的 IP 地址，没有，则请求 DNS 根服务器
2. 根服务器不记录具体域名与 IP 地址的对应关系，会告诉本地 DNS 服务器，可以到域服务器上查询，并给出地址
3. 本地 DNS 服务器向域服务器发起请求，如果有则返回，没有就会返回下级的域名服务器的地址
4. 重复第 3 步，一直返回下级地址，直到找到为止
5. 本地 DNS 服务器把接收到的 IP 地址与域名对应关系保存到缓存中，并且向客户端返回结果

## 传输层
### TCP 和 UDP 区别
- **TCP 传输控制协议：** 面向连接，提供可靠交付，有流量控制、拥塞控制，通过字节流传输，有窗口大小限制，太长的话会被拆分进行发送
- **UDP 用户数据包协议：** 无连接，尽可能最大交付，不可靠，没有拥塞控制，通过报文传输，无论交给 UDP 多长的报文都会一次性发送，会保留报文的边界，不合并不拆分

#### 区别
1. TCP 发送数据前需要建立连接； UDP 不需要
2. TCP 更可靠、稳定，但是效率较低，有延时，占用系统资源高； UDP 传输速度快，但不可靠、不稳定，可能丢包
3. 对网络通信质量有要求，数据准确时用 TCP，如浏览器、邮箱等； 不高、要求快用 UDP，如 QQ语音、视频
4. **本质区别： TCP 面向字节流，UDP 面向报文**： TCP 把应用层传下来的报文看做字节流，把字节流组织成大小不等的数据块； UDP 对应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部。

### TCP 三次握手
<div align="center"> <img src="../../pics/计网/tcp三次握手.png" width="600"/></div>

1. 首先服务器 B 处于 LISTEN（监听）状态，等待客户端 A 的连接请求
2. 客户端向服务器发送连接请求报文段，带有 SYN=1, ACK=0 标志的报文段，选择初始序号 seq=x
3. 服务器收到请求，若同意建立连接，则向客户端发送连接确认报文段，SYN=1, ACK=1, 确认号 ack=x+1，同时也选择一个初始序号 seq=y
4. 客户端收到服务器的连接确认报文段，再向服务器发出确认，ACK=1，同时确认号 akc=y+1
5. 服务器收到客户端的确认后，建立连接

### TCP 四次挥手
<div align="center"> <img src="../../pics/计网/tcp四次挥手.jpg" width="600"/></div>

1. 客户端发送连接释放报文段，FIN=1
2. 服务器收到后发出确认，ACK=1，此时 TCP 属于半关闭状态，服务器能够向客户端发送数据，但客户端不能向服务器发送数据
3. 当服务器不需要连接时，向客户端发送连接释放报文段， FIN=1
4. 客户端收到后发出确认，ACK=1，连接释放

客户端收到服务器的 FIN 报文后，进入 TIME-WAIT 状态，而不是直接 CLOSED，原因为：
1. 确保最后一个确认报文段能够到达，若服务器没收到客户端发送的确认报文段，服务器会重新发送连接释放报文段
2. 可能存在“已失效的连接请求报文段”，为防止这种报文段出现在本次连接之外，需要等待一段时间。这条不懂？？

### TCP 的传输过程
- 确认号ack：期望收到的下一个报文段序号
- 确认ACK： 当 ACK=1 时确认号字段才有效
- 同步SYN： 连接建立时用来同步序号； SYN=1,ACK=0 为连接请求报文段； SYN=1,ACK=1 同意连接的响应报文
- 终止FIN： 用于释放连接

#### 以字节为单位的滑动窗口
接收窗口只会对窗口内最后一个**按序到达**的字节进行确认，知道这个字节前的所有字节都已经被接收

#### 超时重传
TCP 可靠传输靠超时重传实现，若一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。

#### TCP 流量控制
控制发送方的发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，发送方根据这个来设置自己的窗口大小。若为 0，则发送方不能发送数据。

#### TCP 拥塞控制
- TCP 流量控制： 为了让接收方来得及接收
- TCP 拥塞控制： 为了降低整个网络的拥塞程度，防止注入过多的数据到网络中

四种方法： 慢开始、拥塞避免、快重传、快恢复

发送方需要维护一个 拥塞窗口 cwnd 的状态变量，大小取决于网络拥塞程度，并动态变化。

#### 1. 慢开始与拥塞避免
<div align="center"> <img src="../../pics/计网/慢开始与拥塞避免.png" width="800"/> </div>

慢开始： 由小到大逐渐增大发送窗口，也就是拥塞窗口的数值。 
- 从 cwnd=1（1 个报文段）开始发送
- 收到确认后，将 cwnd 翻倍，每次 * 2，之后能够发送的报文段数量为 2, 4, 8 ...

拥塞避免：
- 为了防止 cwnd 增长过大引起的网络拥塞，设置一个慢开始门限 ssthresh，当 cwmd >= ssthresh 时，进入拥塞避免，每次只将 cwnd+1
- 如果出现超时，则 ssthresh = cwnd / 2, 然后重新执行慢开始，重置 cwnd = 1

#### 2. 快重传与快恢复

连续收到三个重复确认，则执行快重传； 然后将 ssthresh = cwnd / 2 执行快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

<div align="center"> <img src="../../pics/计网/快重传.png" width="600"/> </div><br>

## HTTP
### HTTP 与 HTTPS 区别
HTTP 以明文方式发送内容，不提供数据加密，不适合传输敏感信息。  
HTTPS 是在 HTTP 的基础上加入 SSL 协议，依靠证书验证身份，为浏览器与服务器之间的通信加密。
1. HTTP 是明文传输，HTTPS 是具有安全性的 SSL 加密传输协议
2. HTTP 与 HTTPS 的连接方式和用到的端口号不同，HTTP 是 80，HTTPS 是 443
3. HTTP 连接简单，无状态；HTTPS 需要申请证书进行身份认证，更安全

### GET 和 POST 区别
GET 主要是从指定的资源请求数据， POST 是向指定的资源提交要被处理的数据
GET 和 POST 本质上都是 TCP 连接，没有区别，但是由于 HTTP 的规定和浏览器/服务器的限制，其在应用中会体现出一些不同。
1. get 参数一查询字符串出现在 url 中，通过 url 传递，且长度有限制； post 参数存储在内容实体 request body 中，长度无限制。
2. get 比 post 安全性差，因此 get 的参数在 url 中是可见的，不能用于传递隐私信息。
3. get 只支持 ASCII 字符，中文可能会乱码； post 支持标准字符集
3. get 产生 1 个 TCP 数据包；post 产生 2 个 TCP 数据包。