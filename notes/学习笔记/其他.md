<!-- GFM-TOC -->
* [指针和引用的区别](#指针和引用的区别)
* [进程 线程 协程](#进程-线程-协程)
	* [进程和线程的区别](#进程和线程的区别)
	* [协程](#协程)
* [CPU密集型和IO密集型](#CPU密集型和IO密集型)
* [C中的字符串](#C中的字符串)
* [数值的表示](#数值的表示)
	* [原码](#原码)
	* [反码](#反码)
	* [补码](#补码)
<!-- GFM-TOC -->

### 指针和引用的区别
1. 指针是一个实体，而引用只是别名
2. 引用必须被初始化，而指针不用
3. 引用初始化后不可以被改变，指针可以改变所指的对象
4. 不存在指向空值的引用，但存在指向空值的指针

## 进程 线程 协程
### 进程和线程的区别
一个程序至少有一个进程，一个进程至少有一个线程。

1. 根本区别：进程是资源分配的基本单位，线程是程序执行的最小单位
2. 开销方面：每个进程有独立的代码和数据空间，每启动一个进程，系统会为他分配地址空间，进程间的切换有较大开销；同一类线程共享代码和数据空间，切换和创建的开销较小
3. 线程通信更加方便，同一进程下的线程共享全局变量、静态变量等数据；而进程需要以通信方式(IPC)进行
4. 由于进程有自己独立的地址空间，因此多进程程序更加健壮；而多线程程序有一个线程挂掉，全部线程都会挂掉

### 协程
协程 Coroutine：又称微线程，纤程。是一种程序组件，协程看上去是子程序（函数），但在执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  
特点：只有一个线程执行。  
优势：执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗；不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。  
python generator 的 yield 可以在一定程度上实现协程。

- 线程由操作系统控制
- 协程由程序自身控制

### CPU密集型和IO密集型
**CPU 密集型**    
- 也叫计算密集型任务，特点：需要进行大量判断，主要消耗 CPU 资源，大部分时间用于计算、逻辑判断等 CPU 动作的程序，如计算圆周率、视频高清解码等；  
- python 这种脚本语言不适合计算密集型任务，最好用 C 语言；
- python CPU 密集型任务用多进程模型。
  
**IO 密集型**
- 涉及到网络、磁盘 IO 的任务是 IO 密集型任务，特点：CPU 消耗较少，大部分时间在等待 IO 操作完成（IO 操作速度远低于 CPU 和内存的速度）， 如 web 应用；
- IO 密集型任务最合适的语言是开发效率最高（代码量最少）的语言，脚本语言是首选；
- python IO 密集型任务用多线程模型，多线程只使用一个 CPU 核心。


### C中的字符串
在 C/C++ 中的每个字符串都以字符 '\0' 结尾，因此每个字符串都有一个额外字符的开销，把一个长度为 10 的字符串 '0123456789' 需要放到一个长度为 11 的数组中才不会越界。 但 python 中无此规定。

### 数值的表示
计算机中所有的数都以补码形式存在，加减运算都是补码间的加法运算。	

#### 原码
将最高位用来区分正负数，符号位加真值的绝对值。 正数的符号为 0，负数的符号为 1。 这样会出现两个 0，0000(+0) 和 1000(-0)

#### 反码
正数的反码与其原码相同；负数的反码是对原码，除符号位外其余逐位取反。也有两个 0， 0000(+0) 和 1111(-0)

#### 补码
正数的补码是其本身；负数的补码是在反码的基础上 +1

补码的优点： 修复原码中 0 的符号正负之分，及存在两个编码的问题

在 8 位二进制中：
- 使用原码/反码表示的范围为 [-127, +127]， 包含 +0 和 -0 共 256 个数
- 使用补码表示的范围为 [-128, +127]， 0 没有符号